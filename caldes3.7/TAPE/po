                    BEGIN3()
[Begin 3.  BEGIN3 calls BEGIN2, then creates a list of primes
just less than beta which is assigned to the global variable PRIME.]
     safe BEGIN3.
(1)  BEGIN2;  PRIME:=DPGEN(BETA-1000,500) ||
                    A:=DIIPRD(V)
[Distributive integral polynomial read.  V is a variable list.  
A distributive integral polynomial A  in r variables, r=length(V)>=0, 
is read from the input stream.  Any blanks preceding A  are skipped.]
     safe C,e,i,j,k,r,s.
(1)  [r=0.]  if V=() then { A:=IREAD();  return }.
(2)  [Initialize.]  C:=CREADB();  if C # '(' then go to  6;  A:=();
     r:=LENGTH(V).
(3)  [Read coefficient.]  a:=1;  s:=1;  C:=CREADB();  if C='-' then
     s:=-1;  if C='+' \/ C='-' then C:=CREADB();  BKSP;  if DIGIT(C)
     then a:=IREAD();  if s=-1 then a:=INEG(a);  A:=COMP(a,A).
(4)  [Read monic monomial.]  E:=();  i:=1;  repeat {  C:=CREADB();
     BKSP; if ~ LETTER(C) then go to  5;  v:=VREAD();  j:=VLSRCH(v,V);
     if j < i then go to  6;  for k=i,...,j-1 do E:=COMP(0,E);
     E:=COMP(1,E);  C:=CREADB();  BKSP;  if C='*' then { C:=CREAD();
     C:=CREAD();  if C # '*' then go to  6;  e:=AREAD();  SFIRST(E,e) };
     i:=j+1  } until i > r.
(5)  [Complete exponent vector.]  for k=i,...,r do E:=COMP(0,E);
     A:=COMP(E,A);  C:=CREADB();  if C='+' \/ C='-' then { BKSP;
     go to  3 };  if C=')' then { A:=INV(A);  return }.
(6)  [Error.]  print "Error found by DIIPRD.";  DIBUFF;  stop||
                    DIIPWR(r,A,V)
[Distributive integral polynomial write.  A  is a distributive
integral polynomial in r variables, r>=0.  V is a variable list for A.
A  is written in the output stream.]
     safe A',e,s,V',v.
(1)  [r=0 or A=0.]  if r=0 \/ A=0 then { IWRITE(A);  return }.
(2)  [General case.]  A':=A;  CWRITE('(');  repeat {   ADV2(A';a,E,A');
     CWRITE(' ');  s:=ISIGNF(a);  if s > 0 then CWRITE('+');
     IWRITE(a);  E':=CINV(E);  V':=V;  repeat {  ADV(E';e,E');
     ADV(V';v,V');  if e > 0 then { CWRITE(' ');  CLOUT(v) };
     if e > 1 then { CWRIT2('*','*');  AWRITE(e) }  } until E'=()   }
     until A'=();  CWRIT2(' ',')') ||
                    n:=DIPDEG(r,A)
[Distributive polynomial degree.  A  is a distributive polynomial in r
variables, r>=0.  n is the degree of A  in its main variable.]
     safe DIPDEG.
(1)  if r=0 \/ A=0 then n:=0 else n:=FIRST(SECOND(A)) ||
                    B:=DIPFP(r,A)
[Distributive polynomial from polynomial.  A  is a polynomial in r
variables, r>=0.  B is the result of converting A  from recursive 
to distributive representation.]
(1)  [r=0 or A=0.]  if r=0 \/ A=0 then { B:=A;  return }.
(2)  [r=1.]  B:=();  A':=A;  r':=r-1;  if r' > 0 then go to  3;
     repeat { ADV2(A';e1,a1,A');  E1:=LIST1(e1);  B:=COMP2(E1,a1,B) }
     until A'=();  B:=INV(B);  return.
(3)  [Recursion.]  repeat {  ADV2(A';e1,A1,A');  B1:=DIPFP(r',A1);
     repeat { ADV2(B1;b1,E1,B1);  E1:=COMP(e1,E1);  B:=COMP2(E1,b1,B) }
     until B1=() } until A'=();  B:=INV(B) ||
                    A:=DIRPRD(V)
[Distributive rational polynomial read.  V is a variable list.  
A distributive rational polynomial A  in r variables, r=length(V)>=0, 
is read from the input stream.  Any blanks preceding A  are skipped.]
     safe C,e,i,j,k,r,s.
(1)  [r=0.]  if V=() then { A:=RNREAD();  return }.
(2)  [Initialize.]  C:=CREADB();  if C # '(' then go to  6;  A:=();
     r:=LENGTH(V).
(3)  [Read coefficient.]  s:=1;  C:=CREADB();  if C='-' then s:=-1;
     if C='+' \/ C='-' then C:=CREADB();  BKSP;  if DIGIT(C) then
     a:=RNREAD() else a:=RNRED(1,1);  if s=-1 then a:=RNNEG(a);
     A:=COMP(a,A).
(4)  [Read monic monomial.]  E:=();  i:=1;  repeat {  C:=CREADB();
     BKSP; if ~ LETTER(C) then go to  5;  v:=VREAD();  j:=VLSRCH(v,V);
     if j < i then go to  6;  for k=i,...,j-1 do E:=COMP(0,E);
     E:=COMP(1,E);  C:=CREADB();  BKSP;  if C='*' then { C:=CREAD();
     C:=CREAD();  if C # '*' then go to  6;  e:=AREAD();  SFIRST(E,e) };
     i:=j+1  } until i > r.
(5)  [Complete exponent vector.]  for k=i,...,r do E:=COMP(0,E);
     A:=COMP(E,A);  C:=CREADB();  if C='+' \/ C='-' then { BKSP;
     go to  3 };  if C=')' then { A:=INV(A);  return }.
(6)  [Error.]  print "Error found by DIRPRD.";  DIBUFF;  stop||
                    DIRPWR(r,A,V)
[Distributive rational polynomial write.  A  is a distributive
rational polynomial in r variables, r>=0.  V is a variable list for A.
A  is written in the output stream.]
     safe A',e,s,V',v.
(1)  [r=0 or A=0.]  if r=0 \/ A=0 then { RNWRIT(A);  return }.
(2)  [General case.]  A':=A;  CWRITE('(');  repeat {   ADV2(A';a,E,A');
     CWRITE(' ');  s:=RNSIGN(a);  if s > 0 then CWRITE('+');
     RNWRIT(a);  E':=CINV(E);  V':=V;  repeat {  ADV(E';e,E');
     ADV(V';v,V');  if e > 0 then { CWRITE(' ');  CLOUT(v) };
     if e > 1 then { CWRIT2('*','*');  AWRITE(e) }  } until E'=()   }
     until A'=();  CWRIT2(' ',')') ||
                    C:=DMPPRD(r,m,A,B)
[Dense modular polynomial product.  A  and B are polynomials in r
variables over Z_m, m a beta-integer, r>=0. C=A*B.]
     safe a,n.
(1)  [A or B zero.]  if A=0 \/ B=0 then { C:=0;  return }.
(2)  [r=0.]  if r=0 then { C:=MDPROD(m,A,B);  return }.
(3)  [General case.]  ADV(A;e,A');  ADV(B;f,B');  A*:=CINV(A');
     B*:=CINV(B');  C:=0;  r':=r-1;  for i=0,...,f do
     {  C1:=();  for j=1,...,i do C1:=COMP(0,C1);  A':=A*;
     ADV(B*;b,B*);  for j=0,...,e do { ADV(A';a,A');
     if r'=0 then c:=MDPROD(m,a,b) else c:=DMPPRD(r',m,a,b);
     C1:=COMP(c,C1) };  n:=e+i;  while C1 # () /\ FIRST(C1)=0
     do { n:=n-1;  C1:=RED(C1) };  if C1 # () then { C1:=COMP(n,C1);
     C:=DMPSUM(r,m,C1,C) }  } ||
                    C:=DMPSUM(r,m,A,B)
[Dense modular polynomial sum.  A  and B are dense polynomials in r
variables over Z_m, m a beta-integer.  C=A+B.]
     safe a,b,f.
(1)  [A or B zero.]  if A=0 then { C:=B;  return };  if B=0
     then { C:=A;  return }.
(2)  [General case.]  r':=r-1;  if FIRST(A) >= FIRST(B) then
     { ADV(A;e,A');  ADV(B;f,B') } else { ADV(B;e,A');
     ADV(A;f,B') };  C:=();  for i=1,...,e-f do { ADV(A';
     a,A');  C:=COMP(a,C) };  repeat { ADV(A';a,A');
     ADV(B';b,B');  if r'=0 then c:=MDSUM(m,a,b) else
     c:=DMPSUM(r',m,a,b);  C:=COMP(c,C) } until A'=().
(3)  [Finish.]  C:=INV(C);  while C # () /\ FIRST(C)=0 do
     { C:=RED(C);  e:=e-1 };  if C=() then C:=0 else C:=COMP(e,C) ||
                    C:=DMUPNR(p,A,B)
[Dense modular univariate polynomial natural remainder.  A  and B are
non-zero dense univariate polynomials over Z_p, p a prime beta-integer,
with deg(A)>=deg(B).  C is the natural remainder of B.  The list for 
A  is modified.]
     safe DMUPNR.
(1)  [Deg(B)=0.]  n:=FIRST(B);  if n=0 then { C:=0;  return }.
(2)  [Deg(B) positive.]  B':=RED(B);  ADV(B';b,B*);  b':=MDINV(p,b);
     A*:=A;  repeat {   ADV(A*;k,A');  m:=-1;  ADV(A';a,A'');
     c:=MDPROD(p,a,b');  B'':=B*;  repeat {  ADV(B'';b,B'');
     b:=MDPROD(p,b,c);  a:=FIRST(A'');  a:=MDDIF(p,a,b);
     k:=k-1;  if m < 0 /\ a # 0 then { m:=k;  A*:=A' };
     SFIRST(A'',a);  A':=A'';  A'':=RED(A')  } until B''=();
     while m < 0 /\ A'' # () do {  k:=k-1;  if FIRST(A'') # 0
     then { m:=k;  A*:=A' };  A':=A'';  A'':=RED(A')  };  if m >= 0
      then
     SFIRST(A*,m)   } until m < n;  if m >= 0 then C:=A* else C:=0 ||
                    B:=DPFP(r,A)
[Dense polynomial from polynomial.  A  is a polynomial in r variables, 
r>=0.  B is the result of converting A  to dense polynomial 
representation.]
(1)  if A=0 \/ r = 0 then { B:=A;  return };
     n:=PDEG(A);  r':=r-1;  B:=();  A':=A;
     for k=n,n-1,...,0 do {  if A'=() \/ FIRST(A') < k then
     b:=0 else { A':=RED(A');  ADV(A';b,A');  if r' > 0 then
     b:=DPFP(r',b) };  B:=COMP(b,B)  };  B:=COMP(n,INV(B)) ||
                    B:=IPABS(r,A)
[Integral polynomial absolute value.  A  is an integral polynomial in
r>=0 variables.  B is the absolute value of A.]
     safe IPABS.
(1)  s:=IPSIGN(r,A);  if s >= 0 then B:=A else B:=IPNEG(r,A) ||
                    A*:=IPCRA(M,m,m',r,A,a)
[Integral polynomial Chinese remainder algorithm.  M is a positive
integer.  m is a positive beta-integer.  gcd(M,m)=1.  m'= H_m(M)^{-1}.  
A  is an integral polynomial in r variables whose coefficients belong 
to Z'_M, r>=0.  a  is a polynomial in r variables over Z_m.  A* is the 
unique integral polynomial in r variables with coefficients in Z'_{M*}, 
where M*=M*m, which is congruent to A  modulo M and to a  modulo m.]
     safe A1,a1,E,e.
(1)  [r=0.]  if r=0 then { A*:=MIDCRA(M,m,m',A,a);  return }.
(2)  [General case.]  if A=0 then A':=() else A':=A;
     if a=0 then a':=() else a':=a;
     r':=r-1;  A*:=();  while A' # () \/ a' # () do {   if A'=()
     then { A1:=0;  ADV2(a';E*,a1,a') } else if a'=() then { a1:=0;
     ADV2(A';E*,A1,A') } else {  E:=FIRST(A');  e:=FIRST(a');
     if E > e then { ADV2(A';E*,A1,A');  a1:=0 } else if E < e then
     { ADV2(a';E*,a1,a');  A1:=0 } else { ADV2(A';E*,A1,A');
     ADV2(a';E*,a1,a') }  };  if r'=0 then A*1:=MIDCRA(M,m,m',
     A1,a1) else A*1:=IPCRA(M,m,m',r',A1,a1);
     A*:=COMP2(A*1,E*,A*)   };  if A*=() then A*:=0 else A*:=INV(A*) ||
                    B:=IPDER(r,A,i)
[Integral polynomial derivative.  A  is an integral polynomial in r
variables.  1<=i<=r.  B is the derivative of A  with respect to
its i-th variable.]
     safe a.
(1)  [A=0.]  if A=0 then { B:=0;  return }.
(2)  [i=r.]  if i=r then { B:=IPDMV(r,A);  return }.
(3)  [i < r.]  A':=A;  r':=r-1;  B:=();  repeat { ADV2(A';e,a,A');
     b:=IPDER(r',a,i);  if b # 0 then B:=COMP2(b,e,B) }
     until A'=();  B:=INV(B);  if B=() then B:=0 ||
                    C:=IPDIF(r,A,B)
[Integral polynomial difference.  A  and B are integral polynomials in
r variables, r>=0.  C=A-B.]
     safe a,b,C,C'',f.
(1)  [A or B zero.]  if A=0 then { C:=IPNEG(r,B);  return };  if B=0
     then { C:=A;  return }.
(2)  [r=0.]  if r=0 then { C:=IDIF(A,B);  return }.
(3)  [General case.]  A':=A;  B':=B;  C':=();  r':=r-1;  repeat
     {  e:=FIRST(A');  f:=FIRST(B');  if e > f then
     { ADV2(A';e,a,A');  C':=COMP2(a,e,C') } else if e < f then
     { ADV2(B';f,b,B');  if r'=0 then c:=INEG(b) else
     c:=IPNEG(r',b);  C':=COMP2(c,f,C') } else { ADV2(A';e,a,A');
     ADV2(B';f,b,B');  if r'=0 then c:=IDIF(a,b) else
     c:=IPDIF(r',a,b);  if c # 0 then C':=COMP2(c,e,C') }  }
     until A'=() \/ B'=().
(4)  [Finish.]  if A'=() /\ B'=() then C'':=() else if A'=() then
     C'':=IPNEG(r,B') else C'':=A';  C:=INV(C');  if C=() then C:=C''
     else SRED(C',C'');  if C=() then C:=0 ||
                    B:=IPDMV(r,A)
[Integral polynomial derivative, main variable.  A  is an integral
polynomial in r variables.  B is the derivative of A  with respect 
to its main variable.]
     safe a,e'.
(1)  [A=0.]  if A=0 then { B:=0;  return }.
(2)  [General case.]  A':=A;  r':=r-1;  B:=();  repeat
     { ADV2(A';e,a,A');  if r'=0 then b:=IPROD(e,a) else
     b:=IPIP(r',e,a);  e':=e-1;  if e # 0 then B:=COMP2(b,e',B) }
     until A'=();  B:=INV(B);  if B=() then B:=0 ||
                    B:=IPEMV(r,A,a)
[Integral polynomial evaluation of main variable.  A  is an integral
polynomial in r variables.  a  is an integer.
B(x_1,...,x_{r-1})=A(x_1,...,x_{r-1},a).]
     safe A2,A',e1,e2,r'.
(1)  [A=0.]  if A=0 then { B:=0;  return }.
(2)  [Apply Horners method.]  ADV2(A;e1,B,A');  r':=r-1;
     while A' # () do { ADV2(A';e2,A2,A');  for i=1,...,e1-e2 do
     if r'=0 then B:=IPROD(a,B) else B:=IPIP(r',a,B); if r'=0 then
     B:=ISUM(B,A2) else B:=IPSUM(r',B,A2);  e1:=e2 };  for i=1,...,e1
     do if r'=0 then B:=IPROD(a,B) else B:=IPIP(r',a,B) ||
                    B:=IPEVAL(r,A,i,a)
[Integral polynomial evaluation.  A  is an integral polynomial
in r variables.  1<=i<=r.  a  is an integer.  B(x_1,...,
x_{i-1},x_{i+1},...,x_r)=A(x_1,...,x_{i-1},a,x_{i+1},...,x_r).]
     safe A1.
(1)  [A=0.]  if A=0 then { B:=0;  return }.
(2)  [i=r.]  if i=r then { B:=IPEMV(r,A,a);  return }.
(3)  [i < r.]  r':=r-1;  A':=A;  B:=();  repeat { ADV2(A';e1,A1,A');
     B1:=IPEVAL(r',A1,i,a);  if B1 # 0 then B:=COMP2(B1,e1,B) }
     until A'=();  B:=INV(B);  if B=() then B:=0 ||
                    B:=IPEXP(r,A,n)
[Integral polynomial exponentiation.  A  is an integral polynomial 
in r variables, r>=0.  n is a non-negative integer.  B=A^n.]
     safe i.
(1)  [n=0.]  if n=0 then { B:=PINV(0,1,r);  return }.
(2)  [A=0.]  if A=0 then { B:=0;  return }.
(3)  [General case.]  B:=A;  for i=1,...,n-1 do { B:=IPPROD(r,B,A) } ||
                    b:=IPFCB(V)
[Integral polynomial factor coefficient bound.  V is the degree vector
of a non-zero integral polynomial A.  b is a non-negative integer such
that if B_1*...*B_k divides A  then the product of the maximum norms
of the B_i is less than or equal to 2^b times the maximum norm of A.
The bound of Gelfond is used.]
     safe b,n,n1,V'.
(1)  n:=0;  p:=1;  V':=V;  repeat {  ADV(V';n1,V');  if n1 > 0 then
     { n:=n+n1+n1-1;  p:=IPROD(p,n1+1) }  } until V'=();
     n:=n+ILOG2(p);  b:=(n+1)/2 ||
                    B:=IPFRP(r,A)
[Integral polynomial from rational polynomial.  A  is a rational
polynomial in r variables, r>=0, each of whose base coefficients is
an integer.  B is A  converted to integral polynomial representation.]
     safe a.
(1)  [A = 0.]  if A = 0 then { B:=0;  return}.
(2)  [r = 0.]  if r = 0 then { B:=FIRST(A);  return}.
(3)  [r > 0.]  A*:=A;  r':=r-1;  B:=();  repeat
     { ADV2(A*;e,a,A*);  if r' = 0 then b:=FIRST(a)
     else b:=IPFRP(r',a);  B:=COMP2(b,e,B) }
     until A* = ();
     B:=INV(B) ||
                    C:=IPGSUB(r,A,s,L)
[Integral polynomial general substitution.  A  is an integral
polynomial in r variables, r>=1.  L is a list (B_1,...,B_r) of
integral polynomials in s variables, s>=1.  C(y_1,...,y_s)=
A(B_{1}(y_1,...,y_s), ...,B_r(y_1,...,y_s)).]
     safe B,L',t.
(1)  [A=0.]  if A=0 then { C:=0;  return }.
(2)  [A # 0.]  C:=PINV(r,A,s);  L':=L;  t:=r+s;  repeat
     { ADV(L';B,L');  C:=IPSUB(t,C,s+1,B);  t:=t-1 } until L'=() ||
                    B:=IPHDMV(r,A,k)
[Integral polynomial higher derivative, main variable.  A  is an
integral polynomial in r variables.  k is a non-negative 
gamma-integer.  B is the k-th derivative of A  with respect to its 
main variable.]
     safe i.
(1)  B:=A;  i:=k;  while i > 0 /\ B # 0 do { B:=IPDMV(r,B);
     i:=i-1 } ||
                    B:=IPIHOM(r,D,A)
[Integral polynomial mod ideal homomorphism.  D is a list (d_1,...,
d_{r-1}) of positive beta-integers, r>=0. A  is an r-variate 
integral polynomial.  B=A mod (x_1^{d_1},..., x_{r-1}^{d_{r-1}}).]
     safe a,e,r'.
(1)  [r=0 or A=0.]  if r=0 \/ A=0 then { B:=A;  return }.
(2)  [General case.]  r':=r-1;  B:=();  A*:=CINV(A);  while A* # () do
     { ADV2(A*;a,e,A*);  b:=IPTRUN(r',D,a);  if b # 0 then B:=
     COMP2(e,b,B) };  if B=() then B:=0 ||
                    C:=IPIP(r,a,B)
[Integral polynomial integer product.  a  is an integer.  B is an
integral polynomial in r variables.  C=a*B.]
     safe b.
(1)  [C=0.]  if a=0 \/ B=0 then { C:=0;  return }.
(2)  [General case.]  B':=B;  C:=();  r':=r-1;  repeat
     { ADV2(B';e,b,B');  if r'=0 then c:=IPROD(a,b) else
     c:=IPIP(r',a,b);  C:=COMP2(c,e,C) } until B'=();  C:=INV(C) ||
                    C:=IPIPR(r,D,A,B)
[Integral polynomial mod ideal product.  D is a list (d_1,...,d_{r-1})
of positive beta-integers, r>=1.  A  and B belong to
Z[x_1,...,x_{r-1},y]/(x_1^{d_1},...,x_{r-1}^{d_{r-1}}).  C=A*B.]
     safe a,b,e,f.
(1)  [A or B zero.]  if A=0 \/ B=0 then { C:=0;  return }.
(2)  [General case.]  A*:=CINV(A);  B*:=CINV(B);  C:=0;  r':=r-1;
     repeat {  ADV2(B*;b,f,B*);  A':=A*;  C1:=();  repeat { ADV2(A';a,
     e,A');  if r'=0 then c:=IPROD(a,b) else c:=IPTPR(r',D,a,b);
     if c # 0 then C1:=COMP2(e+f,c,C1) } until A'=();  if C1 # ()
     then C:=IPSUM(r,C,C1)  } until B*=() ||
                    C:=IPIQ(r,A,b)
[Integral polynomial integer quotient.  A  is an integral polynomial
in r variables.  b is a non-zero integer which divides A.  C=A/b.]
     safe a.
(1)  [A=0.]  if A=0 then { C:=0;  return }.
(2)  [A # 0.]  A':=A;  r':=r-1;  C:=();  repeat { ADV2(A';e,a,A');
     if r'=0 then c:=IQ(a,b) else c:=IPIQ(r',a,b);
     C:=COMP2(c,e,C) } until A'=();  C:=INV(C) ||
                    b:=IPMAXN(r,A)
[Integral polynomial maximum norm.  A  is an integral polynomial in r
variables.  b is the maximum norm of A.]
     safe a1,e1.
(1)  b:=0;  if A=0 then return;  A':=A;  r':=r-1;  repeat
     { ADV2(A';e1,a1,A');  if r'=0 then b1:=IABSF(a1) else
     b1:=IPMAXN(r',a1);  b:=IMAX(b,b1) } until A'=() ||
                    B:=IPNEG(r,A)
[Integral polynomial negative.  A  is an integral polynomial in r
variables, r>=0.  B=-A.]
     safe a.
(1)  [A=0.]  if A=0 then { B:=0;  return }.
(2)  [r=0.]  if r=0 then { B:=INEG(A);  return }.
(3)  [General case.]  A':=A;  B:=();  r':=r-1;  repeat
     { ADV2(A';e,a,A');  if r'=0 then b:=INEG(a) else
     b:=IPNEG(r',a);  B:=COMP2(b,e,B) } until A'=();  B:=INV(B) ||
                    t:=IPONE(r,A)
[Integral polynomial one.  A  is an integral polynomial in r variables.
If A=1 then t is true and otherwise t is false.]
     safe IPONE.
(1)  t:=FALSE;  if A=0 then return;  a:=A;  for i=1,...,r do
     { if PDEG(a) # 0 then return;  a:=PLDCF(a) };  if a=1
     then t:=TRUE  ||
                    C:=IPPROD(r,A,B)
[Integral polynomial product.  A  and B are integral polynomials in r
variables, r>=0.  C=A*B.]
     safe a.
(1)  [A or B zero.]  if A=0 \/ B=0 then { C:=0;  return }.
(2)  [r=0.]  if r=0 then { C:=IPROD(A,B);  return }.
(3)  [General case.]  A*:=CINV(A);  B*:=CINV(B);  C:=0;  r':=r-1;
     repeat {  ADV2(B*;b,f,B*);  A':=A*;  C1:=();  repeat
     { ADV2(A';a,e,A');  if r'=0 then c:=IPROD(a,b) else
     c:=IPPROD(r',a,b);  C1:=COMP2(e+f,c,C1) } until A'=();
     C:=IPSUM(r,C,C1)  } until B*=() ||
                    C:=IPPSR(r,A,B)
[Integral polynomial pseudo-remainder.  A  and B are integral
polynomials in r variables, B#0.  C is the pseudo-remainder
of A  and B.]
     safe B_,i,l,m,n.
(1)  [Deg(B)=0.]  n:=PDEG(B);  if n=0 then { C:=0;  return }.
(2)  [Deg(B) > 0.]  m:=PDEG(A);  C:=A;  B_:=PRED(B);
     B1:=LIST2(0,PLDCF(B));  for i=m,m-1,...,n do {  if C=0 then
     return;  l:=PDEG(C);  if l=i then { c:=PLDCF(C);
     C:=PRED(C);  C:=IPPROD(r,C,B1);  C1:=LIST2(l-n,c);
     B*:=IPPROD(r,B_,C1);  C:=IPDIF(r,C,B*) } else 
     C:=IPPROD(r,C,B1)  } ||

                    C:=IPQ(r,A,B)
[Integral polynomial quotient.  A  and B are integral polynomials in
r variables, r>=0.  B is a non-zero divisor of A.  C=A/B.]
     safe IPQ.
(1)  if r=0 then C:=IQ(A,B) else IPQR(r,A,B;C,R) ||
                    IPQR(r,A,B;Q,R)
[Integral polynomial quotient and remainder.  A  and B are integral
polynomials in r variables, B#0.  If B|A then Q=A/B and R=0.  Otherwise
A=B*Q+R with deg(R) minimal.]
     safe a,m,R'.
(1)  [Initialize.]  n:=PDEG(B);  b:=PLDCF(B);  B':=PRED(B);  Q:=();
     R:=A;  r':=r-1.
(2)  [Compute quotient terms.]  while R # 0 do { m:=PDEG(R);
     d:=m-n;  if d < 0 then go to  3;  a:=PLDCF(R);
     if r'=0 then IQR(a,b;q,s) else IPQR(r',a,b;q,s);
     if s # 0 then go to  3;  Q:=COMP2(q,d,Q);  Q1:=LIST2(d,q);
     R':=PRED(R);  Q':=IPPROD(r,B',Q1);  R:=IPDIF(r,R',Q') }.
(3)  [Finish.]  if Q=() then Q:=0 else Q:=INV(Q)  ||
                    A:=IPRAN(r,k,q,N)
[Integral polynomial, random.  k is a positive beta-digit.  q is a
rational number q1/q2 with 0<q1<=q2<beta.  N is a list (n_r,...,n_1)
of non-negative beta-digits, r>=0.  A  is a random integral polynonial
in r variables with deg_i(A)<=n_i for 1<=i<=r.  The coefficients of A
are less than 2^k in absolute value.  q is the probability that any 
particular term of A  has a non-zero coefficient.]
     safe d,q1,q2.
(1)  [Compute q*=int(q*beta).]  FIRST2(q;q1,q2);  DQR(q1,0,q2;
     q*,t).
(2)  [r=0.]  if r=0 then { d:=DRANN();  if d < q* then A:=IRAND(k)
     else A:=0;  return }.
(3)  [r > 0.]  r':=r-1;  ADV(N;n,N');  A:=();  for e=0,...,n do
     {  if r'=0 then { d:=DRANN(); if d < q* then a:=IRAND(k) else
     a:=0 } else a:=IPRAN(r',k,q,N');  if a # 0 then A:=COMP2(e,a,
     A)  };  if A=() then A:=0 ||
                    IPREAD(;r,A,V)
[Integral polynomial read.  The integral polynomial A  is read from the
input stream.  r>=0 is the number of variables of A  and V is the 
variable list of A.  Any number of preceding blanks are skipped.]
     safe C,e,r'.
(1)  [r=0.]  C:=CREADB();  if C # '(' then { BKSP;  A:=IREAD();  r:=0;
     V:=();  return }.
(2)  [r positive.]  A:=();  repeat { C:=CREADB();  if C=')' then
     go to  4;  BKSP;  IPREAD(;r',a,V);  C:=CREADB();  if C # '*' then
     go to  3;  v:=VREAD();  C:=CREADB();  if C # '*' then go to  3;
     C:=CREAD();  if C # '*' then go to  3;  e:=AREAD();
     A:=COMP2(a,e,A);  C:=CREADB();  if C=')' then go to  4 else
     if C='-' then BKSP else if C # '+' then go to  3 }.
(3)  [Error.]  print "Error found by IPREAD.";  DIBUFF;  stop.
(4)  [Finish.]  A:=INV(A);  r:=r'+1;  V:=SUFFIX(V,v) ||
                    s:=IPSIGN(r,A)
[Integral polynomial sign.  A  is an integral polynomial in r>=0
variables.  s is the sign of A.]
     safe IPSIGN.
(1)  s:=ISIGNF(PLBCF(r,A))  ||
                    C:=IPSMV(r,A,B)
[Integral polynomial substitution for main variable.  A  is an
integral polynomial in r variables, x_1,...,x_r.  B is an
integral polynomial in x_1,...,x_{r-1}.  C(x_1,...,x_{r-1})=
A(x_1,...,x_{r-1},B(x_1,...,x_{r-1})).]
     safe A2,A',e1,e2,r'.
(1)  [A=0.]  if A=0 then { C:=0;  return }.
(2)  [r=1.]  if r=1 then { C:=IPEMV(r,A,B);  return }.
(3)  [Apply Horners method.]  r':=r-1;  ADV2(A;e1,C,A');  while
     A' # () do { ADV2(A';e2,A2,A');  for i=1,...,e1-e2 do
     C:=IPPROD(r',C,B);  C:=IPSUM(r',C,A2);  e1:=e2 };
     for i=1,...,e1 do C:=IPPROD(r',C,B) ||
                    C:=IPSUB(r,A,i,B)
[Integral polynomial substitution.  A  is an integral polynomial in
r variables, x_1,...,x_r.  1<=i<=r.  B is an integral polynomial in 
x_1,...,x_{i-1}.  C(x_1,...,x_{i-1},x_{i+1},...,x_r) = A(x_1,...,
x_{i-1}, B(x_1,...,x_{i-1}),x_{i+1},..., x_r).]
     safe A1.
(1)  [A=0.]  if A=0 then { C:=0;  return }.
(2)  [i=r.]  if i=r then { C:=IPSMV(r,A,B);  return }.
(3)  [i < r.]  r':=r-1;  A':=A;  C:=();  repeat
     { ADV2(A';e1,A1,A');  C1:=IPSUB(r',A1,i,B);  if C1 # 0 then
     C:=COMP2(C1,e1,C) } until A'=();  C:=INV(C);  if C=() then C:=0 ||
                    C:=IPSUM(r,A,B)
[Integral polynomial sum.  A  and B are integral polynomials in r
variables, r>=0.  C=A+B.]
     safe a,b,C,f.
(1)  [A or B zero.]  if A=0 then { C:=B;  return };  if B=0 then { C:=A;
     return }.
(2)  [r=0.]  if r=0 then { C:=ISUM(A,B);  return }.
(3)  [Match coefficients.]  A':=A;  B':=B;  C':=();  r':=r-1;
     repeat {  e:=FIRST(A');  f:=FIRST(B');  if e > f then
     { ADV2(A';e,a,A');  C':=COMP2(a,e,C') } else if e < f then
     { ADV2(B';f,b,B');  C':=COMP2(b,f,C') } else
     { ADV2(A';e,a,A');  ADV2(B';f,b,B');  if r'=0 then
     c:=ISUM(a,b) else c:=IPSUM(r',a,b);  if c # 0 then
     C':=COMP2(c,e,C') }  } until A'=() \/ B'=().
(4)  [Finish.]  if A'=() then A':=B';  if C'=() then C:=A' else
     { C:=INV(C');  SRED(C',A') };  if C=() then C:=0 ||
                    b:=IPSUMN(r,A)
[Integral polynomial sum norm.  A  is an integral polynomial in r
variables, r>=0.  b is the sum norm of A.]
     safe a1,e1.
(1)  [r=0.]  if r=0 then { b:=IABSF(A);  return }.
(2)  [r > 0.]  b:=0;  if A=0 then return;  A':=A;  r':=r-1;  repeat
     { ADV2(A';e1,a1,A');  if r'=0 then b1:=IABSF(a1) else
     b1:=IPSUMN(r',a1);  b:=ISUM(b,b1) } until A'=() ||
                    C:=IPTPR(r,D,A,B)
[Integral polynomial truncated product.  D is a list (d_1,...,d_r)
of positive beta-integers, r>=1.  A  and B belong to
z[x_1,...,x_r]/(x_1^{d_1},...,x_r^{d_r}).
C=A*B.]
(1)  [A or B zero.]  if A=0 \/ B=0 then { C:=0;  return }.
(2)  [Prepare general case.]  D':=CINV(D);  ADV(D';n,D');  D':=INV(D');
     C:=0;  if n=0 then return;  A*:=CINV(A);  B*:=CINV(B);  r':=r-1.
(3)  [Multiply.]  while B* # () /\ SECOND(B*) < n do {  ADV2(B*;b,
     f,B*);  A':=A*;  C':=();  while A' # () /\ SECOND(A') < n-f do
     { ADV2(A';a,e,A');  if r'=0 then c:=IPROD(a,b) else c:=
     IPTPR(r',D',a,b);  if c # 0 then C':=COMP2(e+f,c,C') };  if
     C' # () then C:=IPSUM(r,C,C')  } ||
                    B:=IPTRAN(r,A,T)
[Integral polynomial translation.  A  is an integral polynomial in r
variables, r>=1.  T is a list (t_r,...,t_1) of integers.
B(x_1,...,x_r)=A(x_1+t_1,...,x_r+t_r).]
(1)  [Translate main variable.]  ADV(T;t,T');  B:=IPTRMV(r,A,t).
(2)  [Translate coefficients.]  r':=r-1;  if r'=0 \/ B=0
     then return;  B':=B;  B:=();  repeat { ADV2(B';e,b',B');
     b:=IPTRAN(r',b',T');  B:=COMP2(b,e,B) }  until B'=();
     B:=INV(B) ||
                    B:=IPTRMV(r,A,h)
[Integral polynomial translation, main variable.  A  is an integral
polynomial in r variables, r>=1.  h is an integer.
B(x_1,...,x_r)=A(x_1,...,x_{r-1},x_r+h).]
     safe a,A',e,e',r.
(1)  [A=0 or h=0.]  if A=0 \/ h=0 then { B:=A;  return }.
(2)  [General case.]  ADV2(A;e,a,A');  B:=LIST2(0,a);  repeat
     {  if A'=() then e':=0 else e':=FIRST(A');
     for i=1,...,e-e' do { B1:=PMPMV(B,1);  B2:=IPIP(r,h,B);
     B:=IPSUM(r,B1,B2) };  if A'=() then return;  ADV2(A';e,a,A');
     a_:=LIST2(0,a);  B:=IPSUM(r,B,a_)  }||
                    B:=IPTRUN(r,D,A)
[Integral polynomial truncation.  D is a list (d_1,...,d_r) of
positive beta-integers, r>=0.  A  is an r-variate integral
polynomial.  B=A mod (x_1^{d_1},...,x_r^{d_r}.]
(1)  [r=0 or A=0.]  if r=0 \/ A=0 then { B:=A;  return }.
(2)  [Initialize.]  r':=r-1;  A*:=CINV(A);  B:=();  D':=CINV(D);  ADV(D'
;
     d,D');  D':=INV(D').
(3)  [Generate terms.]  while A* # () /\ SECOND(A*) < d do { ADV2(
     A*;a,e,A*);  if r'=0 then b:=a else b:=IPTRUN(r',D',a);  if
     b # 0 then B:=COMP2(e,b,B) };  if B=() then B:=0 ||
                    IPWRIT(r,A,V)
[Integral polynomial write.  A  is an integral polynomial in r
variables, r>=0.  V is a variable list for A.  A  is written in the
output stream in external canonical form.]
     safe a,i.
(1)  [r=0 or A=0.]  if r=0 \/ A=0 then { IWRITE(A);  return }.
(2)  [A non-zero.]  CWRITE('(');  A':=A;  r':=r-1;  V_:=CINV(V);
     ADV(V_;V1,V');  V':=INV(V');
     i:=0;  repeat {  ADV2(A';e,a,A');  if i # 0 /\
     (r > 1 \/ ISIGNF(a) > 0) then CWRITE('+');  if r'=0 then
     IWRITE(a) else IPWRIT(r',a,V');  CWRITE('*');  CLOUT(V1);
     CWRITE('*');  CWRITE('*');  IWRITE(e);  i:=1  } until A'=();
     CWRITE(')') ||
                    b:=IUPBEI(A,c,m)
[Integral univariate polynomial binary rational evaluation, integer
output.  A  is a univariate integral polynomial.  c is an integer.  m
is a non-negative beta-integer.  b=2^{n*m}*A(c/2^m) where n=deg(A).
b is an integer.]
     safe a,A',e,k,n.
(1)  [A=0.]  if A=0 then { b:=0;  return }.
(2)  [Apply Horner method.]  ADV2(A;n,b,A');  k:=1;
     while k <= n do {  b:=IPROD(b,c);  if A' # () /\
     FIRST(A')=n-k then { ADV2(A';e,a,A');  a':=ITRUNC(a,-m * k);
     b:=ISUM(b,a') };  k:=k+1  } ||
                    s:=IUPBES(A,a)
[Integral univariate polynomial binary rational evaluation of sign.
A  is a univariate polynomial.  a  is a binary rational number.  
s=sign(A(a)).]
     safe IUPBES.
(1)  if A=0 then s:=0 else {  if a=0 then { c:=0;  m:=0 } else
     { FIRST2(a;c,d);  m:=IORD2(d) };  b:=IUPBEI(A,c,m);
     s:=ISIGNF(b)  } ||
                    B:=IUPBHT(A,k)
[Integral univariate polynomial binary homothetic transformation.  A  is
a non-zero univariate integral polynomial.  k is a gamma-integer.
B(x)=2^{-h}*A(2^k*x) where h is uniquely determined so that B is an
integral polynomial not divisible by 2.]
     safe a,A',e,h,m,n.
(1)  [Compute h.]  A':=A;  h:=BETA;  repeat { ADV2(A';e,a,A');
     m:=IORD2(a);  n:=k * e+m;  if n < h then h:=n } until
     A'=().
(2)  [Compute B.]  A':=A;  B:=();  repeat { ADV2(A';e,a,A');
     b:=ITRUNC(a,h-k * e);  B:=COMP2(b,e,B) } until A'=();
     B:=INV(B) ||
                    b:=IUPBRE(A,a)
[Integral univariate polynomial binary rational evaluation.  A  is a
univariate integral polynomial.  a  is a binary rational number.  
b=A(a), a binary rational number.]
     safe b,c,d,h,k,m,n.
(1)  [A=0.]  b:=0;  if A=0 then return.
(2)  [A # 0.]  if a=0 then { c:=0;  m:=0 } else { FIRST2(a;c,d);
     m:=IORD2(d) };  b1:=IUPBEI(A,c,m);  if b1=0 then return;
     k:=IORD2(b1);  n:=FIRST(A);  h:=m * n;  if k >= h then
     { b1:=ITRUNC(b1,h);  b2:=1 } else { b1:=ITRUNC(b1,k);
     h:=h-k;  b2:=IMP2(1,h) };  b:=LIST2(b1,b2) ||
                    B:=IUPCHT(A)
[Integral univariate polynomial circle to half-plane transformation.
A  is a non-zero univariate integral polynomial.  Let n=deg(A).  Then
B(x)=(x+1)^n*A(1/(x+1)), a univariate integral polynomial.]
     safe B.
(1)  A':=PRT(A);  B:=IUPTR1(A') ||
                    B:=IUPNT(A)
[Integral univariate polynomial negative transformation.  A  is a 
univariate integral polynomial.  B(x)=A(-x).]
     safe A',e.
(1)  if A=0 then { B:=0;  return };  B:=();  A':=A;  repeat { ADV2(A';
     e,a,A');  if ODD(e)=1 then a:=INEG(a);  B:=COMP2(a,e,B) }
     until A'=();  B:=INV(B) ||
                    C:=IUPTPR(n,A,B)
[Integral univariate polynomial truncated product.  n is a non-
negative integer.  A  and B are integral univariate polynomials.  C(x)=
A(x)*B(x) (modulo x^n) and C=0 or deg(C) < n.]
(1)  [n=0 or A=0 or B=0.]  C:=0;  if n=0 \/ A=0 \/ B=0 then return.
(2)  [General case.]  A*:=CINV(A);  B*:=CINV(B);  while B* # () /\
     SECOND(B*) < n do {  ADV2(B*;b,f,B*);  A':=A*;  C':=();  while
     A' # () /\ SECOND(A') < n-f do { ADV2(A';a,e,A');  c:=IPROD(
     a,b);  C':=COMP2(e+f,c,C') };  if C' # () then C:=IPSUM(1,C,C')
       } ||
                    B:=IUPTR(A,h)
[Integral univariate polynomial translation.  A  is a univariate
integral polynomial.  h is an integer.  B(x)=A(x+h).]
     safe b,i,j,L',n.
(1)  [Degree zero.]  n:=PDEG(A);  if n=0 then { B:=A;  return }.
(2)  [Compute coefficient list.]  L:=PCL(A).
(3)  [Apply synthetic division.]  for i=n,n-1,...,1 do
     {  ADV(L;a,L');  for j=1,...,i do { b:=FIRST(L');
     a:=IPROD(a,h);  a:=ISUM(a,b);  SFIRST(L',a);  L':=RED(L') }  }.
(4)  [Convert coefficient list to polynomial.]  B:=();  L:=INV(L);
     for i=0,...,n do { ADV(L;a,L);  if a # 0 then
     B:=COMP2(i,a,B) } ||
                    B:=IUPTR1(A)
[Integral univariate polynomial translation by 1.  A  is a univariate
integral polynomial.  B(x)=A(x+1).]
     safe a',a1,A',c,e,f,f_,h,i,j,k,m,n,PAD[5000],s,t.
(1)  [Degree zero.]  n:=PDEG(A);  if n=0 then { B:=A;  return }.
(2)  [Compute maximum coefficient length.]  f_:=0;  A':=A;
     repeat { A':=RED(A');  ADV(A';a,A');  f:=ILOG2(a);
     if f > f_ then f_:=f } until A'=().
(3)  [Store coefficients in array.]  k:=(f_+n+ZETA-1)/ZETA;
     m:=k * (n+1);  if m > 500 then { print
     "ARRAY PAD TOO SMALL FOR IUPTR1";  stop };  A':=A;  i:=1;
     for h=n,n-1,...,0 do {  if A'=() then e:=-1 else e:=FIRST(A');
     if e=h then ADV2(A';e,a,A') else a:=0;  a':=a;  if a' <
     BETA then a':=LIST1(a');  for j=1,...,k do { if a' # ()
     then ADV(a';a1,a') else a1:=0;  PAD[i]:=a1;  i:=i+1 }  }.
(4)  [Apply synthetic division.]  for h=n,n-1,...,1 do
     {   c:=0;  m:=m-k;  for i=1,...,m do {  s:=PAD[i]+PAD[i+k]+
     c;  c:=0;  if s >= BETA then { s:=s-BETA;  c:=1 } else
     if s <= -BETA then { s:=s+BETA;  c:=-1 };  PAD[i+k]:=s  }   }.
(5)  [Convert B to normal form.]  B:=();  e:=0;  i:=k * n;
     repeat {    a:=();  j:=k;  repeat { s:=PAD[i+j];  j:=j-1 }
     until s # 0 \/ j=0;  if s # 0 then {   c:=0;  h:=i+1;
     j:=j+1;  for t=1,...,j do {  a1:=PAD[h]+c;  c:=0;
     if s > 0 /\ a1 < 0 then { a1:=a1+BETA;  c:=-1 };
     if s < 0 /\ a1 > 0 then { a1:=a1-BETA;  c:=1 };
     a:=COMP(a1,a);  h:=h+1  };  while FIRST(a)=0 do a:=RED(a);
     if RED(a)=() then a:=FIRST(a) else a:=INV(a);
     B:=COMP2(e,a,B)   };  e:=e+1;  i:=i-k    } until e > n ||
                    C:=MIPDIF(r,M,A,B)
[Modular integral polynomial difference.  M is a positive integer.
A  and B are polynomials in r variables over Z_M, r >= 0.  C=A-B.]
     safe a,b,C,C'',f.
(1)  [A or B zero.]  if A=0 then { C:=MIPNEG(r,M,B);  return };
     if B=0 then { C:=A;  return }.
(2)  [r=0.]  if r=0 then { C:=MIDIF(M,A,B);  return }.
(3)  [General case.]  A':=A;  B':=B;  C':=();  r':=r-1;  repeat {
     e:=FIRST(A');  f:=FIRST(B');  if e > f then { ADV2(A';e,a,A');
     C':=COMP2(a,e,C') } else if e < f then { ADV2(B';f,b,B');
     if r'=0 then c:=MINEG(M,b) else c:=MIPNEG(r',M,b);
     C':=COMP2(c,f,C') } else { ADV2(A';e,a,A');  ADV2(B';f,b,B');
     if r'=0 then c:=MIDIF(M,a,b) else c:=MIPDIF(r',M,a,b);
     if c # 0 then C':=COMP2(c,e,C') }  } until A'=() \/ B'=().
(4)  [Finish.]  if A'=() /\ B'=() then C'':=() else if A'=() then
     C'':=MIPNEG(r,M,B') else C'':=A';  C:=INV(C');  if C=() then C:=C''

     else SRED(C',C'');  if C=() then C:=0 ||
                    B:=MIPFSM(r,M,A)
[Modular integral polynomial from symmetric modular.  M is a positive
integer.  A  is a polynomial in r variables over Z'_M, r>=0.
B belongs to Z_M[x_1,...,x_r] with B congruent to A  (modulo M).]
     safe a.
(1)  [A=0.]  if A=0 then { B:=0;  return }.
(2)  [r=0.]  if r=0 then { if ISIGNF(A) < 0 then B:=ISUM(M,A) else
     B:=A;  return }.
(3)  [General case.]  A':=A;  B:=();  r':=r-1;  repeat { ADV2(A';e,a,
     A');  b:=MIPFSM(r',M,a);  B:=COMP2(b,e,B) } until A'=();
     B:=INV(B) ||
                    B:=MIPHOM(r,M,A)
[Modular integral polynomial homomorphism.  A  is an integral
polynomial in r variables, r>=0.  M is a positive integer.
B=H_M (A), a polynomial in r variables over Z_M.]
     safe a.
(1)  [A=0.]  if A=0 then { B:=0;  return }.
(2)  [r=0.]  if r=0 then { B:=MIHOM(M,A);  return }.
(3)  [General case.]  A':=A;  B:=();  r':=r-1;  repeat { ADV2(A';e,a,
     A');  if r'=0 then b:=MIHOM(M,a) else b:=MIPHOM(r',M,a);  if
     b # 0 then B:=COMP2(b,e,B) } until A'=();  if B=() then B:=0
     else B:=INV(B) ||
                    C:=MIPIPR(r,M,D,A,B)
[Modular integral polynomial mod ideal product.  D is a list (d_1,
...,d_{r-1}) of positive beta-integers, r>=1.  M is a positive
integer.  A  and B belong to Z_M [x_1,...,x_{r-1},y] /
(x_1^{d_1},...,x_{r-1}^{d_{r-1}}).  C=A*B.]
(1)  C':=IPIPR(r,D,A,B);  C:=MIPHOM(r,M,C') ||
                    B:=MIPNEG(r,M,A)
[Modular integral polynomial negation.  M is a positive integer.  A  is
a polynomial in r variables over Z_M, r >= 0.  B=-A.]
     safe a.
(1)  [A=0.]  if A=0 then { B:=0;  return }.
(2)  [r=0.]  if r=0 then { B:=MINEG(M,A);  return }.
(3)  [General case.]  A':=A;  B:=();  r':=r-1;  repeat { ADV2(A';e,a,
     A');  if r'=0 then b:=MINEG(M,a) else b:=MIPNEG(r',M,a);
     B:=COMP2(b,e,B) } until A'=();  B:=INV(B) ||
                    C:=MIPPR(r,M,A,B)
[Modular integral polynomial product.  M is a positive integer.  A  and
B are polynomials in r variables over Z_M, r>=0.  C=A*B.]
(1)  C:=MIPHOM(r,M,IPPROD(r,A,B)) ||
                    A:=MIPRAN(r,M,q,N)
[Modular integral polynomial, random.  M is a positive integer.  q is
a rational number q1/q2 with 0<q1<=q2<beta.  N is a list (n_r,...,n_1) 
of non-negative beta-digits, r>=0.  A  is a random polynomial in r 
variables over Z_M with deg_i(A)<=n_i for 1<=i<=r.  q is the probability
that any particular term of A  has a non-zero coefficient.]
     safe d,q1,q2.
(1)  [Compute q*=int(q*beta).]  FIRST2(q;q1,q2);  DQR(q1,0,q2;
     q*,t).
(2)  [r=0.]  if r=0 then { d:=DRANN();  if d < q* then A:=MIRAN(M)
     else A:=0;  return }.
(3)  [r > 0.]  r':=r-1;  ADV(N;n,N');  A:=();  for e=0,...,n do
     {  if r'=0 then { d:=DRANN();  if d < q* then a:=MIRAN(M) else
     a:=0 } else a:=MIPRAN(r',M,q,N');  if a # 0 then A:=COMP2(e,a,
     A)  };  if A=() then A:=0 ||
                    C:=MIPSUM(r,M,A,B)
[Modular integral polynomial sum.  M is a positive integer.  A  and B
are polynomials in r variables over Z_M, r>=0.  C=A+B.]
     safe a,b,C,f.
(1)  [A or B zero.]  if A=0 then { C:=B;  return };  if B=0 then { C:=A;
     return }.
(2)  [r=0.]  if r=0 then { C:=MISUM(M,A,B);  return }.
(3)  [Match coefficients.]  A':=A;  B':=B;  C':=();  r':=r-1;  repeat
     {  e:=FIRST(A');  f:=FIRST(B');  if e > f then { ADV2(A';e,a,
     A');  C':=COMP2(a,e,C') } else if e < f then { ADV2(B';f,b,
     B');  C':=COMP2(b,f,C') } else { ADV2(A';e,a,A');  ADV2(B';f,
     b,B');  if r'=0 then c:=MISUM(M,a,b) else c:=MIPSUM(r',M,a,
     b);  if c # 0 then C':=COMP2(c,e,C') }  } until A'=() \/ B'=().
(4)  [Finish.]  if A'=() then A':=B';  if C'=() then C:=A' else { C:=
     INV(C');  SRED(C',A') };  if C=() then C:=0 ||
                    MIUPQR(M,A,B;Q,R)
[Modular integral univariate polynomial quotient and remainder.  M is a
positive integer.  A  and B belong to Z_M (x) with ldcf(B) a unit.
Q and R are the unique elements of Z_M (x) such that A=B*Q+R with
either R=0 or deg(R) < deg(B).]
     safe a,b,B',d,m,n,R'.
(1)  [Initialize.]  n:=PDEG(B);  b:=PLDCF(B);  B':=PRED(B);  Q:=();  R:=
A;
     b':=MIINV(M,b).
(2)  [Compute quotient terms.]  while R # 0 do { m:=PDEG(R);  d:=m-
     n;  if d < 0 then go to  3;  a:=PLDCF(R);  q:=MIPROD(M,a,b');
     Q:=COMP2(q,d,Q);  Q1:=LIST2(d,q);  R':=PRED(R);  Q':=MIPPR(1,M,B',
     Q1);  R:=MIPDIF(1,M,R',Q') }.
(3)  [Finish.]  if Q=() then Q:=0 else Q:=INV(Q) ||
                    MMPIQR(r,M,D,A,B;Q,R)
[Modular monic polynomial mod ideal quotient and remainder.  M is a
positive integer.  D is a list (d_1,...,d_{r-1}) of non-negative
beta-integers, r>=1.  A  and B belong to Z_M[x_1,...,x_{r-1},y] /
(x_1^{d_1},...,x_{r-1}^{d_{r-1}}), with B monic.  A=B*Q+R, 
deg_y(R)<deg_y(B) unless B|A, in which case R=0, with Q, R belonging 
to Z_M[x_1,...,x_{r-1},y]/(x_1^{d_1},...,x_{r-1}^{d_{r-1}}).]
     safe a,B',m,n,R'.
(1)  [Initialize.]  n:=PDEG(B);  B':=PRED(B);  Q:=();  R:=A.
(2)  [Compute quotient terms.]  while R # 0 do { m:=PDEG(R);  d:=m-
     n;  if d < 0 then go to  3;  a:=PLDCF(R);  Q:=COMP2(a,d,Q);
     Q1:=LIST2(d,a);  R':=PRED(R);  Q':=MIPIPR(r,M,D,B',Q1);  R:=MIPDIF(

     r,M,R',Q') }.
(3)  [Finish.]  if Q=() then Q:=0 else Q:=INV(Q) ||
                    C:=MPDIF(r,m,A,B)
[Modular polynomial difference.  A  and B are polynomials in r>=1
variables over Z_m, m a beta-integer.  C=A-B.]
     safe a,b,C,C'',f.
(1)  [A or B zero.]  if A=0 then { C:=MPNEG(r,m,B);  return };
     if B=0 then { C:=A;  return }.
(2)  [General case.]  A':=A;  B':=B;  C':=();  r':=r-1;  repeat
     {  e:=FIRST(A');  f:=FIRST(B');  if e > f then
     { ADV2(A';e,a,A');  C':=COMP2(a,e,C') } else if e < f then
     { ADV2(B';f,b,B'); if r'=0 then c:=MDNEG(m,b) else
     c:=MPNEG(r',m,b); C':=COMP2(c,f,C') }
     else { ADV2(A';e,a,A');  ADV2(B';f,b,B');  if r'=0 then
     c:=MDDIF(m,a,b) else c:=MPDIF(r',m,a,b);  if c # 0 then
     C':=COMP2(c,e,C') }  } until A'=() \/ B'=().
(3)  [Finish.]  if A'=() /\ B'=() then C'':=() else if A'=() then
     C'':=MPNEG(r,m,B') else C'':=A';  C:=INV(C');  if C=() then C:=C''
     else SRED(C',C'');  if C=() then C:=0 ||
                    B:=MPEMV(r,m,A,a)
[Modular polynomial evaluation of main variable.  A  is a polynomial in
r variables over Z_m, m a beta-integer.  a  is an element of
Z_m.  B(x_1,...,x_{r-1})=A(x_1,...,x_{r-1},a).]
     safe a1,A',e1,e2,i,r'.
(1)  [A=0.]  if A=0 then { B:=0;  return }.
(2)  [Apply Horners method.]  ADV(A;e1,A');  B:=0;  r':=r-1;
     repeat { ADV(A';a1,A');  if r'=0 then B:=MDSUM(m,B,a1) else
     B:=MPSUM(r',m,B,a1);  if A' # () then ADV(A';e2,A') else e2:=0;
     for i=1,...,e1-e2 do if r'=0 then B:=MDPROD(m,a,B) else
     B:=MPMDP(r',m,a,B);  e1:=e2 } until A'=() ||
                    B:=MPEVAL(r,m,A,i,a)
[Modular polynomial evaluation.  A  is a polynomial in r variables
over Z_m, m a beta-integer.  1<=i<=r.  a  is an element of Z_m.  
B(x_1,...,x_{i-1},x_{i+1},...,x_r)=
A(x_1,...,x_{i-1},a,x_{i+1},...,x_r).]
     safe A1.
(1)  [A=0.]  if A=0 then { B:=0;  return }.
(2)  [i=r.]  if i=r then { B:=MPEMV(r,m,A,a);  return }.
(3)  [i < r.]  r':=r-1;  A':=A;  B:=();  repeat { ADV2(A';e1,A1,A');
     B1:=MPEVAL(r',m,A1,i,a);  if B1 # 0 then B:=COMP2(B1,e1,B) }
     until A'=();  if B=() then B:=0 else B:=INV(B) ||
                    B:=MPEXP(r,m,A,n)
[Modular polynomial exponentiation.  A  is a polynomial in r>=0 
variables over Z_m, m a beta-integer.  n is a non-negative integer.  
B=A^n.]
     safe i.
(1)  [n=0.]  if n=0 then { B:=PINV(0,1,r);  return }.
(2)  [A=0.]  if A=0 then { B:=0;  return }.
(3)  [General case.]  B:=A;  for i=1,...,n-1 do B:=MPPROD(r,m,B,A) ||
                    B:=MPHOM(r,m,A)
[Modular polynomial homomorphism.  A  is an integral polynomial in r
variables, r>=0.  m is a positive beta-integer.  B=H_m(A), a polynomial 
in r variables over Z_m.]
     safe a.
(1)  [A=0.]  if A=0 then { B:=0;  return }.
(2)  [r=0.]  if r=0 then { B:=MDHOM(m,A);  return }.
(3)  [General case.]  r':=r-1;  A':=A;  B:=();  repeat
     { ADV2(A';e,a,A');  if r'=0 then b:=MDHOM(m,a) else
     b:=MPHOM(r',m,a);  if b # 0 then B:=COMP2(b,e,B) }
     until A'=(); B:=INV(B); if B=() then B:=0 ||
                    A*:=MPINT(p,B,b,b',r,A,A1)
[Modular polynomial interpolation.  p is a prime beta-integer.  B is
a univariate polynomial over Z_p.  b is an element of Z_p such that
B(b)#0 and b'=B(b)^{-1}.  A  is a polynomial over Z_p in r variables,
r>=1, with A=0 or deg_1(A)<deg(B).  A1 is a polynomial over Z_p in 
r-1 variables.  A*(x_1,...,x_r) is the unique polynomial over Z_p
such that A*(x_1,...,x_r) is congruent to A(x_1,...,x_r) modulo 
B(x_1), A*(b,x_2,...,x_r)=A1(x_2,...,x_r) and deg_1(A*)<=deg(B).]
     safe a,a1,c,d,e,e1,n.
(1)  [Deg(B)=0.]  n:=PDEG(B);  if n=0 then { A*:=PINV(r-1,A1,1);
     return }.
(2)  [r=1.]  if r=1 then {  a:=MPEMV(1,p,A,b);  d:=MDDIF(p,A1,a);
     if d=0 then A*:=A else { c:=MDPROD(p,d,b');  A*:=MPSUM(1,p,
     MPMDP(1,p,c,B),A) };  return  }.
(3)  [r>1.]  A*:=();  r':=r-1;  if A=0 then A':=() else A':=A;
     if A1=0 then A'1:=() else A'1:=A1;  while A' # () \/ A'1 # () do
     { if A'=() then { a:=0;ADV2(A'1;e*,a1,A'1) } else if A'1=() then
     { a1:=0;  ADV2(A';e*,a,A') } else { e:=FIRST(A');
     e1:=FIRST(A'1);  e*:=MAX(e,e1);  a:=0;  a1:=0;  if e=e* then
     ADV2(A';e,a,A');  if e1=e* then ADV2(A'1;e1,a1,A'1) };
     a*:=MPINT(p,B,b,b',r',a,a1);  A*:=COMP2(a*,e*,A*)  };
     if A*=() then A*:=0 else A*:=INV(A*) ||
                    C:=MPMDP(r,p,a,B)
[Modular polynomial modular digit product.  a  is an element of
Z_p, p a prime beta-integer.  B is a polynomial in r>=1 variables
over Z_p.  C=a*B.]
     safe b.
(1)  [C=0.]  if a=0 \/ B=0 then { C:=0;  return }.
(2)  [General case.]  B':=B;  C:=();  r':=r-1;  repeat
     { ADV2(B';e,b,B');  if r'=0 then c:=MDPROD(p,a,b) else
     c:=MPMDP(r',p,a,b);  C:=COMP2(c,e,C) } until B'=();
     C:=INV(C) ||
                    A':=MPMON(r,p,A)
[Modular polynomial monic.  A  is a polynomial in r>=1 variables over
Z_p, p a prime beta-integer.  If A  is non-zero then A' is
the polynomial similar to A  with lbcf(A')=1.  If A=0 then A'=0.]
     safe MPMON.
(1)  [A=0.]  if A=0 then { A':=0;  return }.
(2)  [A non-zero.]  a:=PLBCF(r,A);  a':=MDINV(p,a);  A':=MPMDP(r,
     p,a',A) ||
                    B:=MPNEG(r,m,A)
[Modular polynomial negative.  A  is a polynomial in r>=1 variables 
over Z_m, m a beta-integer.  B=-A.]
     safe a.
(1)  [A=0.]  if A=0 then { B:=0;  return }.
(2)  [A non-zero.]  A':=A;  B:=();  r':=r-1;  repeat
     { ADV2(A';e,a,A');  if r'=0 then b:=MDNEG(m,a) else
     b:=MPNEG(r',m,a);  B:=COMP2(b,e,B) } until A'=();  B:=INV(B) ||
                    C:=MPPROD(r,m,A,B)
[Modular polynomial product.  A  and B are polynomials in r variables
over Z_m, m a beta-integer, r>=0.  C=A*B.]
     safe a.
(1)  [A or B zero.]  if A=0 \/ B=0 then { C:=0; return }.
(2)  [r=0.]  if r=0 then { C:=MDPROD(m,A,B);  return }.
(3)  [General case.]  A*:=CINV(A);  B*:=CINV(B);  C:=0;  r':=r-1;
     repeat {  ADV2(B*;b,f,B*);  A':=A*;  C1:=();  repeat
     { ADV2(A';a,e,A');  if r'=0 then c:=MDPROD(m,a,b) else
     c:=MPPROD(r',m,a,b);  if c # 0 then C1:=COMP2(e+f,c,C1) }
     until A'=();  if C1 # () then C:=MPSUM(r,m,C,C1)  } until B*=() ||
                    C:=MPPSR(r,p,A,B)
[Modular polynomial pseudo-remainder.  A  and B are polynomials
in r>=1 variables over Z_p, p a prime beta-integer,
with B non-zero.  C is the pseudo-remainder of A  and B.]
     safe B_,i,l,m,n.
(1)  [Deg(B)=0.]  n:=PDEG(B);  if n=0 then { C:=0;  return }.
(2)  [Deg(B) > 0.]  m:=PDEG(A);  C:=A;  B_:=PRED(B);
     B1:=LIST2(0,PLDCF(B));  for i=m,m-1,...,n do {  if C=0 then
     return;  l:=PDEG(C);  if l=i then { c:=PLDCF(C);
     C:=PRED(C);  C:=MPPROD(r,p,C,B1);  C1:=LIST2(l-n,c);
     B*:=MPPROD(r,p,B_,C1);  C:=MPDIF(r,p,C,B*) } else
     C:=MPPROD(r,p,C,B1)  } ||
                    C:=MPQ(r,p,A,B)
[Modular polynomial quotient.  A  and B are polynomials in r
variables over Z_p, p a prime beta-integer, r>=0.  B is a
non-zero divisor of A.  C=A/B.]
     safe MPQ.
(1)  if r=0 then C:=MDQ(p,A,B) else MPQR(r,p,A,B;C,R) ||
                    MPQR(r,p,A,B;Q,R)
[Modular polynomial quotient and remainder.  A  and B are polynomials
in r>=1 variables over Z_p, p a prime beta-integer, with B non-zero.
Q and R are the unique polynomials such that either B|A, Q=A/B
and R=0 or else B does not divide A  and A=B*Q+R with deg(R) minimal.]
     safe a,m,R'.
(1)  [Initialize.]  n:=PDEG(B);  b:=PLDCF(B);  B':=PRED(B);  Q:=();
     R:=A;  r':=r-1.
(2)  [Compute quotient terms.]  while R # 0 do {  m:=PDEG(R);
     d:=m-n;  if d < 0 then go to  3;  a:=PLDCF(R);
     if r'=0 then { q:=MDQ(p,a,b);  s:=0 } else MPQR(r',p,a,
     b;q,s);  if s # 0 then go to  3;  Q:=COMP2(q,d,Q);
     Q1:=LIST2(d,q);  R':=PRED(R);  Q':=MPPROD(r,p,B',Q1);
     R:=MPDIF(r,p,R',Q')  }.
(3)  [Finish.]  if Q=() then Q:=0 else Q:=INV(Q) ||
                    A:=MPRAN(r,m,q,N)
[Modular polynomial, random.  m is a positive beta-integer.  q is a
rational number q1/q2 with 0<q1<=q2<beta.  N is a list (n_r,
...,n_1) of non-negative beta-digits, r>=0.  A  is a
random polynomial in r variables over Z_m with deg_i(A)<=n_i 
for 1<=i<=r.  q is the probability that any particular
term of A  has a non-zero coefficient.]
     safe d,q1,q2.
(1)  [Compute q*=int(q*beta).]  FIRST2(q;q1,q2);  DQR(q1,0,q2;
     q*,t).
(2)  [r=0.]  if r=0 then { d:=DRANN();  if d < q* then A:=MDRAN(m)
     else A:=0;  return }.
(3)  [r>0.]  r':=r-1;  ADV(N;n,N');  A:=();  for e=0,...,n do
     {  if r'=0 then { d:=DRANN(); if d < q* then a:=MDRAN(m) else
     a:=0 } else a:=MPRAN(r',m,q,N');  if a # 0 then A:=COMP2(e,a,
     A)  };  if A=() then A:=0 ||
                    C:=MPSUM(r,m,A,B)
[Modular polynomial sum.  A  and B are polynomials in r>=1 variables 
over Z_m, m a beta-integer.  C=A+B.]
     safe a,b,C,f.
(1)  [A or B zero.]  if A=0 then { C:=B;  return };  if B=0 then { C:=A;
     return }.
(2)  [General case.]  A':=A;  B':=B;  C':=();  r':=r-1;  repeat
     {  e:=FIRST(A');  f:=FIRST(B');  if e > f then
     { ADV2(A';e,a,A');  C':=COMP2(a,e,C') } else if e < f then
     { ADV2(B';f,b,B');  C':=COMP2(b,f,C') } else
     { ADV2(A';e,a,A');  ADV2(B';f,b,B');  if r'=0 then
     c:=MDSUM(m,a,b) else c:=MPSUM(r',m,a,b);  if c # 0 then
     C':=COMP2(c,e,C') }  } until A'=() \/ B'=().
(3)  [Finish.]  if A'=() then A':=B';  if C'=() then C:=A' else
     { C:=INV(C');  SRED(C',A') };  if C=() then C:=0 ||
                    B:=MPUP(r,m,c,A)
[Modular polynomial univariate product.  A  is a polynomial in r
variables, r>=1, over Z_m, m a positive beta-integer.  c is a
univariate polynomial over Z_m.  B(x_1,...,x_r)=
c(x_1)*A(x_1,...,x_r).]
     safe a.
(1)  [c=0 or A=0.]  if c=0 \/ A=0 then { B:=0;  return }.
(2)  [r=1.]  if r=1 then { B:=MPPROD(r,m,c,A);  return }.
(3)  [General case.]  r':=r-1;  A':=A;  B:=();  repeat
     { ADV2(A';e,a,A');  b:=MPUP(r',m,c,a);  if b # 0 then
     B:=COMP2(b,e,B) } until A'=();  if B=() then B:=0 else 
     B:=INV(B) ||
                    C:=MPUQ(r,p,A,b)
[Modular polynomial univariate quotient.  A  is a polynomial in r
variables, r>=2, over Z_p, p a prime beta-integer.  b is a
non-zero univariate polynomial over Z_p which divides A.
C(x_1,...,x_r)= A(x_1,...,x_r)/b(x_1).]
     safe a.
(1)  [A=0.]  if A=0 then { C:=0;  return }.
(2)  [A non-zero.]  A':=A;  r':=r-1;  C:=();  repeat
     { ADV2(A';e,a,A');  if r'=1 then c:=MPQ(r',p,a,b) else
     c:=MPUQ(r',p,a,b);  C:=COMP2(c,e,C) } until A'=();
     C:=INV(C) ||
                    B:=MUPDER(m,A)
[Modular univariate polynomial derivative.  m is a beta-integer.  A  is
a univariate polynomial over Z_m.  B is the derivative of A, a
univariate polynomial over Z_m.]
     safe a,A',e.
(1)  [A=0.]  if A=0 then { B:=0;  return }.
(2)  [A # 0.]  B:=();  A':=A;  repeat {  ADV2(A';e,a,A');
     a:=MDPROD(m,e,a);  if a # 0 then { e:=e-1;
     B:=COMP2(a,e,B) }  } until A'=();  if B=() then B:=0
     else B:=INV(B) ||
                    A:=MUPRAN(p,n)
[Modular univariate polynomial, random.  A  is a random univariate
polynomial of degree n over Z_p.]
     safe a,i.
(1)  A:=();  for i=0,...,n-1 do { a:=MDRAN(p);  if a # 0 then
     A:=COMP2(i,a,A) };  a:=MDRAN(p-1)+1;  A:=COMP2(n,a,A) ||
                    A:=PBIN(a1,e1,a2,e2)
[Polynomial binomial.  a1 and a2 are elements of a coefficient ring
R.  e1 and e2 are non-negative beta-integers e1>e2.  A  is the
polynomial A(x)=a1*x^{e1}+a2*x^{e2}, a univariate polynomial over R.]
(1)  A:=();  if a2 # 0 then A:=LIST2(e2,a2);  if a1 # 0 then
     A:=COMP2(e1,a1,A);  if A = () then A:=0 ||
                    L:=PCL(A)
[Polynomial coefficient list.  A  is a non-zero polynomial.  L is the
list (a_n,a_{n-1},...,a_0) where n=deg(A) and A(x)=a_n*x^n+
a_{n-1}*x^{n-1}+...+a_0.]
     safe a,A',e,m,n.
(1)  A':=A;  n:=FIRST(A');  L:=();  for m=n,n-1,...,0 do
     { if A'=() then e:=-1 else e:=FIRST(A');  if e=m then
     ADV2(A';e,a,A') else a:=0;  L:=COMP(a,L) };  L:=INV(L) ||
                    B:=PDBORD(A)
[Polynomial divided by order.  A  is a non-zero polynomial.  B(x)=
A(x)/x^k where k is the order of A.]
     safe a,A',e,k.
(1)  k:=PORD(A);  if k=0 then B:=A else {  B:=();  A':=A;
     repeat { ADV2(A';e,a,A');  e:=e-k;  B:=COMP2(a,e,B) }
     until A'=();  B:=INV(B)  } ||
                    n:=PDEG(A)
[Polynomial degree.  A  is a polynomial.  n is the degree of A.]
     safe PDEG.
(1)  if A=0 then n:=0 else n:=FIRST(A) ||
                    n:=PDEGSV(r,A,i)
[Polynomial degree, specified variable.  A  is a polynomial in r
variables, r >= 1.  1<=i<=r.  n is the degree of A  in the i-th
variable.]
     safe a,e,n1.
(1)  [A=0.]  if A=0 then { n:=0;  return }.
(2)  [i=r.]  if i=r then { n:=PDEG(A);  return }.
(3)  [General case.]  n:=0;  A':=A;  r':=r-1;  repeat
     { ADV2(A';e,a,A');  n1:=PDEGSV(r',a,i);  n:=MAX(n,n1) }
     until A'=() ||
                    V:=PDEGV(r,A)
[Polynomial degree vector.  A  is a polynomial A(x_1,...,x_r) in
r>=1 variables.  V is the list (v_r,...,v_1) where v_i is the
degree of A  in x_i.]
     safe A1.
(1)  [A=0.]  if A=0 then { V:=();  for i=1,...,r do V:=COMP(0,V);
     return }.
(2)  [r=1.]  n:=PDEG(A);  if r=1 then { V:=LIST1(n);  return }.
(3)  [r>1.]  r':=r-1;  A1:=PLDCF(A);  V:=PDEGV(r',A1);  A':=PRED(A);
     while A' # 0 do { A1:=PLDCF(A');  V1:=PDEGV(r',A1);  V:=VMAX(V,V1);
     A':=PRED(A') };  V:=COMP(n,V) ||
                    B:=PDPV(r,A,i,n)
[Polynomial division by power of variable.  A  is a polynomial in
r variables.  1<=i<=r and n is a beta-integer such that x_i^n|A.
B = A/x_i^n.]
(1)  [A=0 or n=0.]  if A = 0 \/ n = 0 then { B:=A;  return }.
(2)  [General case.]  A':=A;  B:=();  r':=r-1;  repeat
     {  ADV2(A';e,a,A');  if i = r then { b:=a;  f:=e-n }
     else { b:=PDPV(r',a,i,n);  f:=e };  B:=COMP2(b,f,B)  }
     until A' = ();  B:=INV(B) ||
                    B:=PFDIP(r,A)
[Polynomial from distributive polynomial.  A  is a distributive
polynomial in r variables, r>=0.  B is the result of converting A
to recursive representation.]
     safe a1,e1,E1.
(1)  [r=0 or A=0.]  if r=0 \/ A=0 then { B:=A;  return }.
(2)  [r=1.]  B:=();  A':=A;  r':=r-1;  if r' > 0 then go to  3;
     repeat { ADV2(A';a1,E1,A');  e1:=FIRST(E1);  B:=COMP2(a1,e1,B) }
     until A'=();  B:=INV(B);  return.
(3)  [Recursion.]  repeat {   e:=DIPDEG(r,A');  A1:=();  repeat
     {  e1:=DIPDEG(r,A');  if e1=e then { ADV2(A';a1,E1,A');
     E1:=RED(E1);  A1:=COMP2(E1,a1,A1) }  } until e1 # e \/ A'=();
     A1:=INV(A1);  B1:=PFDIP(r',A1);  B:=COMP2(B1,e,B)   } until A'=();
     B:=INV(B) ||
                    B:=PFDP(r,A)
[Polynomial from dense polynomial.  A  is a dense polynomial in
r variables, r>=0.  B is the result of converting A  to recursive
polynomial representation.]
(1)  if A=0 \/ r = 0 then { B:=A;  return };  ADV(A;n,A');
     B:=();  r':=r-1;  repeat {  ADV(A';b,A');
     if b # 0 then { if r' # 0 then
     b:=PFDP(r',b);  B:=COMP2(b,n,B) };  n:=n-1  } until A'=();
     B:=INV(B) ||
                    B:=PINV(r,A,k)
[Polynomial introduction of new variables.  A  is a polynomial in r
variables, r>=0.  k>=0.  B(y_1,...,y_k,x_1,...,x_r)=A(x_1,...,x_r).]
     safe i.
(1)  [A=0 or k=0.]  if A=0 \/ k=0 then { B:=A;  return }.
(2)  [r=0.]  if r=0 then { B:=A;  for i=1,...,k do B:=LIST2(0,B);
     return }.
(3)  [r>0.]  r':=r-1;  A':=A;  B:=();  repeat
     { ADV2(A';e1,A1,A');  B1:=PINV(r',A1,k);  B:=COMP2(B1,e1,B) }
     until A'=();  B:=INV(B) ||
                    a:=PLBCF(r,A)
[Polynomial leading base coefficient.  A  is a polynomial in r>=0
variables.  a  is the leading base coefficient of A.]
     safe PLBCF.
(1)  if A=0 then a:=0 else {  a:=A;  for i=1,...,r do
     { a:=PLDCF(a) }  }  ||
                    a:=PLDCF(A)
[Polynomial leading coefficient.  A  is a polynomial.  a  is the
leading coefficient of A.]
     safe PLDCF.
(1)  if A=0 then a:=0 else a:=SECOND(A) ||
                    n:=PMDEG(A)
[Polynomial modified degree.  A  is a polynomial.  If A=0 then n=-1
and otherwise n=deg(A).]
     safe PMDEG.
(1)  if A=0 then n:=-1 else n:=FIRST(A) ||
                    A:=PMON(a,e)
[Polynomial monomial.  a  is an element of a coefficient ring R.
e is a non-negative beta-integer.  A  is the polynomial
A(x)=a*x^e, a univariate polynomial over R.]
     safe PMON.
(1)  if a = 0 then A:=0 else A:=LIST2(e,a) ||
                    B:=PMPMV(A,k)
[Polynomial multiplication by power of main variable.  A  is a
polynomial in r variables, r>=1.  k is a non-negative integer.
B(x_1,...,x_r)=A(x_1,...,x_r)*x_r^k .]
     safe a,A',e.
(1)  [A=0 or k=0.]  if A = 0 \/ k = 0 then { B:=A;  return }.
(2)  [General case.]  B:=();  A':=A;  repeat { ADV2(A';e,a,A');
     B:=COMP2(a,e+k,B) } until A' = ();  B:=INV(B) ||
                    k:=PORD(A)
[Polynomial order.  A  is a non-zero polynomial.  k is the order of A.]
     safe PORD.
(1)  A':=A;  repeat { ADV(A';k,A');  A':=RED(A') } until A'=() ||
                    B:=PRED(A)
[Polynomial reductum.  A  is a polynomial.  B is the reductum of A.]
     safe PRED.
(1)  if A=0 then B:=0 else { B:=RED2(A);  if B=() then B:=0 } ||
                    B:=PRT(A)
[Polynomial reciprocal transformation.  A  is a non-zero polynomial.
Let n=deg(A).  Then B(x)=x^n*A(1/x), where x is the main variable of A.]
     safe a,A',e,n.
(1)  n:=FIRST(A);  A':=A;  B:=();  repeat { ADV2(A';e,a,A');
     e:=n-e;  B:=COMP2(e,a,B) } until A'=() ||
                    a:=PTBCF(r,A)
[Polynomial trailing base coefficient.  A is an r-variate polynomial,
r>=0.  a is the trailing base coefficient of A.]
     safe b,e.
(1)  [r=0 or A=0.]  if r=0 \/ A=0 then { a:=A;  return }.
(2)  [General case.]  r':=r-1;  A*:=CINV(A);  ADV2(A*;b,e,A*);  if e   =
0 then a:=PTBCF(r',b) else a:=0 ||
                    B:=PUFP(r,A)
[Polynomial, univariate, from polynomial.  A  is an r-variate
polynomial, r>=1.  B(x)=A(0,...,0,x).]
     safe a,e,r'.
(1)  [r=1 or A=0.]  if r=1 \/ A=0 then { B:=A;  return }.
(2)  [General case.]  r':=r-1;  B:=();  A':=A;  while A' # () do
     { ADV2(A';e,a,A');  b:=PTBCF(r',a);  if b # 0 then B:=COMP2(
     b,e,B) };  if B=() then B:=0 else B:=INV(B) ||
                    C:=RPDIF(r,A,B)
[Rational polynomial difference.  A  and B are rational polynomials in
r variables, r >= 0.  C=A-B.]
     safe a,b,C,C'',f.
(1)  [A or B zero.]  if A=0 then { C:=RPNEG(r,B);  return };  if B=0
     then { C:=A;  return }.
(2)  [r=0.]  if r=0 then { C:=RNDIF(A,B);  return }.
(3)  [General case.]  A':=A;  B':=B;  C':=();  r':=r-1;  repeat
     {  e:=FIRST(A');  f:=FIRST(B');  if e > f then
     { ADV2(A';e,a,A');  C':=COMP2(a,e,C') } else if e < f then
     { ADV2(B';f,b,B');  if r'=0 then c:=RNNEG(b) else
     c:=RPNEG(r',b);  C':=COMP2(c,f,C') } else { ADV2(A';e,a,A');
     ADV2(B';f,b,B');  if r'=0 then c:=RNDIF(a,b) else
     c:=RPDIF(r',a,b);  if c # 0 then C':=COMP2(c,e,C') }  }
     until A'=() \/ B'=().
(4)  [Finish.]  if A'=() /\ B'=() then C'':=() else if A'=() then
     C'':=RPNEG(r,B') else C'':=A';  C:=INV(C');  if C=() then C:=C''
     else SRED(C',C'');  if C=() then C:=0 ||
                    C:=RPEMV(r,A,b)
[Rational polynomial evaluation, main variable.  A  is a rational
polynomial in r variables, r > 0.  b is a rational number.
C(x_1,...,x_{r-1})=A(x_1,...,x_{r-1},b).]
     safe A',a,e,e',r'.
(1)  [A=0.]  if A=0 then { C:=0;  return }.
(2)  [Horner method.]  A':=A;  C:=0;  r':=r-1;  repeat
     { ADV2(A';e,a,A');  if A'=() then e':=0 else e':=FIRST(A');
     C:=RPSUM(r',C,a);  for i=1,...,e-e' do C:=RPRNP(r',b,C) }
     until A'=() ||
                    B:=RPFIP(r,A)
[Rational polynomial from integral polynomial.  A  is an integral
polynomial in r variables, r>=0.  B=A, a rational polynomial.]
     safe a.
(1)  [A=0.]  if A=0 then { B:=0;  return }.
(2)  [r=0.]  if r=0 then { B:=RNINT(A);  return }.
(3)  [Recursion on r.]  B:=();  A':=A;  r':=r-1;  repeat
     { ADV2(A';e,a,A');  b:=RPFIP(r',a);  B:=COMP2(b,e,B) }
     until A'=();  B:=INV(B) ||
                    B:=RPIMV(r,A)
[Rational polynomial integration, main variable.  A  is a rational
polynomial in r variables, r>0.  B is the integral of A  with
respect to its main variable.  The constant of integration is 0.]
     safe A',a,e,e',r'.
(1)  [A=0.]  if A=0 then { B:=0;  return }.
(2)  [A # 0.]  A':=A;  r':=r-1;  B:=();  repeat { ADV2(A';
     e,a,A');  e':=e+1;  e*:=LIST2(1,e');  b:=RPRNP(r',
     e*,a);  B:=COMP2(b,e',B) } until A'=();  B:=INV(B) ||
                    B:=RPNEG(r,A)
[Rational polynomial negative.  A  is an rational polynomial in r
variables, r>=0.  B=-A.]
     safe a.
(1)  [A=0.]  if A=0 then { B:=0;  return }.
(2)  [r=0.]  if r=0 then { B:=RNNEG(A);  return }.
(3)  [General case.]  A':=A;  B:=();  r':=r-1;  repeat
     { ADV2(A';e,a,A');  if r'=0 then b:=RNNEG(a) else
     b:=RPNEG(r',a);  B:=COMP2(b,e,B) } until A'=();  B:=INV(B) ||
                    C:=RPPROD(r,A,B)
[Rational polynomial product.  A  and B are rational polynomials in r
variables, r>=0.  C=A*B.]
     safe a.
(1)  [A or B zero.]  if A=0 \/ B=0 then { C:=0;  return }.
(2)  [r=0.]  if r=0 then { C:=RNPROD(A,B);  return }.
(3)  [General case.]  A*:=CINV(A);  B*:=CINV(B);  C:=0;  r':=r-1;
     repeat {  ADV2(B*;b,f,B*);  A':=A*;  C1:=();  repeat
     { ADV2(A';a,e,A');  if r'=0 then c:=RNPROD(a,b) else
     c:=RPPROD(r',a,b);  C1:=COMP2(e+f,c,C1) } until A'=();
     C:=RPSUM(r,C,C1)  } until B*=() ||
                    RPQR(r,A,B;Q,R)
[Rational polynomial quotient and remainder.  A  and B are rational
polynomials in r variables with B#0.  Q and R are the unique
rational polynomials such that either B|A, Q=A/B and R=0 or else
B does not divide A  and A=B*Q+R with deg(R) minimal.]
     safe a,m,R'.
(1)  [Initialize.]  n:=PDEG(B);  b:=PLDCF(B);  B':=PRED(B);  Q:=();
     R:=A;  r':=r-1.
(2)  [Compute quotient terms.]  while R # 0 do { m:=PDEG(R);
     d:=m-n;  if d < 0 then go to  3;  a:=PLDCF(R);
     if r'=0 then {q:=RNQ(a,b);  s:=0}
     else RPQR(r',a,b;q,s);
     if s # 0 then go to  3;  Q:=COMP2(q,d,Q);  Q1:=LIST2(d,q);
     R':=PRED(R);  Q':=RPPROD(r,B',Q1);  R:=RPDIF(r,R',Q') }.
(3)  [Finish.]  if Q=() then Q:=0 else Q:=INV(Q) ||
                    RPREAD(;r,A,V)
[Rational polynomial read.  The rational polynomial A  is read from the
input stream.  r>=0 is the number of variables of A  and V is the
variable list of A.  Any number of preceding blanks are skipped.]
     safe C,e,r'.
(1)  [r=0.]  C:=CREADB();  if C # '(' then { BKSP;  A:=RNREAD();  r:=0;
     V:=();  return }.
(2)  [r > 0.]  A:=();  repeat { C:=CREADB();  if C=')' then go to  4;
     BKSP;  RPREAD(;r',a,V);  C:=CREADB();  if C # '*' then go to  3;
     v:=VREAD();  C:=CREADB();  if C # '*' then go to  3;  C:=CREAD();
     if
     C # '*' then go to  3;  e:=AREAD();  A:=COMP2(a,e,A);  C:=CREADB();
     if C=')' then go to  4 else if C='-' then BKSP else
     if C # '+' then go to  3 }.
(3)  [Error.]  print "Error found by RPREAD.";  DIBUFF;  stop.
(4)  [Finish.]  A:=INV(A);  r:=r'+1;  V:=SUFFIX(V,v) ||
                    C:=RPRNP(r,a,B)
[Rational polynomial rational number product.  B is a rational
polynomial in r variables, r>=0.  a  is a rational number.  C=a*B.]
     safe b.
(1)  [a=0 or B=0.]  if a=0 \/ B=0 then { C:=0;  return }.
(2)  [r=0.]  if r=0 then { C:=RNPROD(a,B);  return }.
(3)  [General case.]  C:=();  B':=B;  r':=r-1;  repeat
     { ADV2(B';e,b,B');  c:=RPRNP(r',a,b);  C:=COMP2(c,e,C) }
     until B'=();  C:=INV(C) ||
                    C:=RPSUM(r,A,B)
[Rational polynomial sum.  A  and B are rational polynomials in r
variables, r>=0.  C=A+B.]
     safe a,b,C,f.
(1)  [A=0 or B=0.]  if A=0 then { C:=B;  return };  if B=0
     then { C:=A;  return }.
(2)  [r=0.]  if r=0 then { C:=RNSUM(A,B);  return }.
(3)  [Match coefficients.]  A':=A;  B':=B;  C':=();  r':=r-1;
     repeat {  e:=FIRST(A');  f:=FIRST(B');  if e > f
     then { ADV2(A';e,a,A');  C':=COMP2(a,e,C') } else
     if e < f then { ADV2(B';f,b,B');  C':=COMP2(b,f,C') }
     else { ADV2(A';e,a,A');  ADV2(B';f,b,B');  if r'=0
     then c:=RNSUM(a,b) else c:=RPSUM(r',a,b);
     if c # 0 then C':=COMP2(c,e,C') }  } until A'=()
     \/ B'=().
(4)  [Finish.]  if A'=() then A':=B';  if C'=() then C:=A'
     else { C:=INV(C');  SRED(C',A') };  if C=() then C:=0 ||
                    RPWRIT(r,A,V)
[Rational polynomial write.  A  is a rational polynomial in r
variables, r>=0.  V is a variable list for A.  A  is written
in the output stream in external canonical form.]
     safe a,i.
(1)  [r=0 or A=0.]  if r=0 \/ A=0 then { IWRITE(A);  return }.
(2)  [A # 0.]  CWRITE('(');  A':=A;  r':=r-1;  V_:=CINV(V);  ADV(V_;
     V1,V');  V':=INV(V');  i:=0;  repeat { ADV2(A';e,a,A');  
     if i # 0 /\ (r > 1 \/ RNSIGN(a) > 0) then CWRITE('+'); if r'=0 
     then RNWRIT(a) else RPWRIT(r',a,V');  CWRITE('*');  CLOUT(V1);
     CWRITE('*');  CWRITE('*');  IWRITE(e);  i:=1 } until A'=();
     CWRITE(')') ||
                    B:=SMFMIP(r,M,A)
[Symmetric modular from modular integral polynomial.  M is a positive
integer.  A  is a polynomial in r variables over Z_M, r>=0.  B
belongs to Z'_M [x_1,...,x_r] and is congruent to A (modulo M).]
     safe a.
(1)  [A=0.]  if A=0 then { B:=0;  return }.
(2)  [r=0.]  if r=0 then { B:=SMFMI(M,A);  return }.
(3)  [General case.]  A':=A;  B:=();  r':=r-1;  repeat
     { ADV2(A';e,a,A');  if r'=0 then b:=SMFMI(M,a) else b:=
     SMFMIP(r',M,a);  B:=COMP2(b,e,B) } until A'=();  B:=INV(B) ||
                    t:=VCOMP(U,V)
[Vector comparison.  U=(u_1,...,u_r) and V=(v_1,...,v_r)
are lists of beta-integers with common length r>=1.  If U=V
then t=0.  If U#V then t=1 if u_i<=v_i for all i and t=2 if
v_i<=u_i for all i.  Otherwise t=3.]
     safe VCOMP.
(1)  t1:=0;  t2:=0;  U*:=U;  V*:=V;  repeat { ADV(U*;u,U*);
     ADV(V*;v,V*);  if u < v then t1:=1 else if v < u
     then t2:=2 } until U*=();  t:=t1+t2 ||
                    V:=VLREAD()
[Variable list read.  V, a list of variables, is read from the input
stream.  Any preceding blanks are skipped.]
     safe C.
(1)  [Read variables.]  V:=();  C:=CREADB();  if C # '(' then go to  2;
     C:=CREADB();  if C=')' then return else BKSP;  repeat
     {  v:=VREAD();  V:=COMP(v,V);  C:=CREADB();  if C=')' then
     { V:=INV(V);  return } else if C # ',' then go to  2  }.
(2)  [Error.]  print "Error found by VLREAD.";  DIBUFF;  stop||
                    i:=VLSRCH(v,V)
[Variable list search.  v is a variable.  V is a list of variables
(v_1,...,v_n), n>=0.  If v=v_j for some j then i=j.  Otherwise i=0.]
     safe VLSRCH.
(1)  [Initialize.] V':=V;  i:=1.
(2)  [Search.]  while V' # () do { ADV(V';v1,V'); if EQUAL(v,v1)=1 then
     return;  i:=i+1 }.
(3)  [Not found.]  i:=0 ||
                    VLWRIT(V)
[Variable list write.  V, a list of variables, is written in the
output stream.]
     safe VLWRIT.
(1)  V':=V;  CWRITE('(');  if V'=() then { CWRITE(')');  return } else
     { ADV(V';v,V');  CLOUT(v) };  while V' # () do { CWRITE(',');
     ADV(V';v,V');  CLOUT(v) };  CWRITE(')') ||
                    W:=VMAX(U,V)
[Vector maximum.  U=(u_1,...,u_r) and V=(v_1,...,v_r) are
lists of beta-integers with common length r>=1.  W=(w_1,...,w_r)
where w_i=max(u_i,v_i).]
     safe u,U*,v,V*,w.
(1)  W:=();  U*:=U;  V*:=V;  repeat { ADV(U*;u,U*);  ADV(V*;v,V*);
     w:=MAX(u,v);  W:=COMP(w,W) } until U*=();  W:=INV(W) ||
                    W:=VMIN(U,V)
[Vector minimum.  U=(u_1,...,u_r) and V=(v_1,...,v_r) are
lists of beta-integers with common length r>=1.  W=(w_1,...,w_r)
where w_i=min(u_i,v_i).]
     safe u,U*,v,V*,w.
(1)  W:=();  U*:=U;  V*:=V;  repeat { ADV(U*;u,U*);  ADV(V*;v,V*);
     w:=MIN(u,v);  W:=COMP(w,W) } until U*=();  W:=INV(W) ||
                    c:=VMPIP(r,m,A,B)
[Vector of modular polynomial inner product.  A  and B are vectors of
modular polynomials in r variables over Z_m, r non-negative, m a
beta-integer.  c is the inner product of A  and B.]
     safe a,A',b,B'.
(1)  [A=0 or B=0.]  c:=0;  if A=0 \/ B=0 then return.
(2)  [General case.]  A':=A;  B':=B;  repeat { ADV(A';a,A');
     ADV(B';b,B');  if r=0 then c:=MDSUM(m,c,MDPROD(m,a,b))
     else c:=MPSUM(r,m,c,MPPROD(r,m,a,b)) } until A'=() ||
                    v:=VREAD()
[Variable read.  The variable v is read from the input stream.  Any
number of preceding blanks are skipped.]
     safe C.
(1)  C:=CREADB();  if ~LETTER(C) then { print "Error found by VREAD.";
     DIBUFF;  stop };
     v:=();  repeat { v:=COMP(C,v);  C:=CREAD() } until ~(LETTER(C)
     \/DIGIT(C));
     v:=INV(v);  BKSP  ||
