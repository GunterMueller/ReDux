Introduction to the SAC-2 List Processing System

The SAC-2 List Processing System depends on the SAC-2 Basic System, and all subsequent SAC-2 systems depend on the SAC-2 List Processing System. In the following we define the terminology associated with the List Processing System, define the internal and external list representations used in SAC-2, explain the important system global variables (and arrays) used by the system, and mention many of the algorithms of the system. The separate document "SAC-2 Global Variables" contains a complete accounting of the global variables of the List Processing System. This system also contains some algorithms for operations on sets, for example union, intersection and difference, and the representations of sets as lists are defined.

An atom in SAC-2 is a b-integer, that is, an integer a such that /a/ < b. b is a system implementation parameter. b must be a single-precision power of 2, b=2z, with z³6. Moreover, one must have 3b²g where g is the largest integer such that every g-integer is a single-precision Fortran integer. b is stored as the value of the system global variable BETA.

Let A be the set of all atoms, and let C be the closure of A under the operation of finite sequence formation. The elements of C are called objects. The objects which are not atoms are called lists. Thus, recursively, a list is just a finite sequence of atoms and/or other lists. The length of a list L=(u1,...,un) is its length n as a finite sequence, which is independent of the length of any element ui which is itself a list. The finite sequence () of length 0 is included; it is called the null list. 

We define various functions on lists and objects. If u is an object and L is a list then M=comp(u,L), the composition of u and L, is the list (u,u1,...,un) if L=(u1,...,un). It is easy to verify that if M is any non-null list then there is a unique object u and a unique list L such that M=comp(u,L). u is the first element of M, u=first(M), and L is the reductum of M, L=red(M). Comp, first and red are the three basic list processing functions; all others can be defined in terms of these.

The inverse of the list L=(u1,...,un) is the list L'=(un,...,u1); we write L'=inv(L). The concatenation of the lists L=(u1,...un) and M=(v1,...,vm) is the list P=(u1,...,un,v1,...,vm); we write P=conc(L,M).

We define the order of an atom is 0 and the extent of the null list to be 1. Recursively, if M is any non-null list then the order of M is the maximum of the order of first (M) plus 1 and the order of red (M); symbolically, order (M)=max(order(first(M))+1,order(red(M))). The order of a non-null list is one more than the maximum order of any of its elements.

The extent of an atom is 0 and the extent of the null list is 0. For a non-null list M, extent(M)=extent(first(M)+extent(red(M))+1. Any object can be uniquely expressed in terms of atoms, the null list, and applications of comp. The extent of the object is the number of occurences of "comp" in this expression.

We shall also have occasion to speak of the second, third, or fourth element of a list. We have second (M)=first(red(M)), third(M)=first(red(red(M))), and fourth(M)=first(red(red(red(M)))) whenever these are defined. We also write red2(M) for red(red(M)), red3(M) for red(red2(M)), etc.

Lists, as we have defined them, are abstract mathematical objects. A list is a finite sequence and a finite sequence of length n is a function whose domain is the set of integers {1,...,n}. We write (u1,...,un) for the function u whose value at i, 1²i²n, is ui. As an abstract object a list must be distinguished both from its external representation as a sequence of symbols and its internal representation in the memory of a computer, both of which remain to be defined. We begin with the latter.

In the computer memory, all list representations are scattered about in a large system global array called SPACE. SPACE is a one-dimensional array having n elements, where n is also a system global variable. The elements of SPACE are paired into cells, each cell consisting of an element with odd index i and the following element with even index i+1. b+1 is called the location of this cell. The reason for adding b is to distinguish atoms from cell locations. The first of these two array elements is called the reductum field  of the cell, and the second is called the element field.

A representation of a non-null list A in the array SPACE consists of a non-empty set S of cells, one of which is distinguished as the first cell, the location of which, L, is called location of the representation. Let us write R(A,S,L) to denote that S is a set of cells with location L representing A. The null list is represented without any cells and we adopt the convention that b is the location of the representation; thus R((), {},b). Now we proceed to define R(A,S,L) by induction on extent (A). Let A1=first(A) and A'=red(A). If A1 is an atom, R(A',S',L') holds, C is a cell with location L, C S', if the reductum field of C contains L' and the element field of C contains A1, then R(A,S`U {C},L) holds. If A1 is a list, R(A1,S1,Ls) holds, R(A',S',L') holds, C is a cell with location L, CeS1, CeS', if the reductum field of C contains L' and the element field of C contains L1, then R(A,S1US'{C},L) holds. In no other case does R(A,S,L) hold.

It is easy to see that if R(A,S,L) holds then the set S is uniquely determined by L; also, A is uniquely  determined. Thus it is meaningful to say that L is the location of a representation of A. In the algorithm descriptions of SAC-2, we will say that an input or an output is a list, but what is really meant is that the input or output is the location of a list representation.

It is often useful to use diagrams for list representations. For example, following is a diagram for a representation of the list (0,(),(1)):

Note that a cell field containing neither an atom nor an arrow-tail contains b, the location of the null list. In this example the number of cells in the representation is equal to the extent of the list represented, namely four. Sometimes fewer cells suffice. For example, for the list ((0),(),(0)) we can have the diagram:

Here the extent of the list is five, but only four cells occur in the representation. In such a case we say that overlapping  occurs. This is an example of overlapping in the representation of a single list, but we may also have overlapping of the representations of two or more lists. For example, every representation of L=((1,2,3)) requires extent (L)=4 cells and every representation of M=(1),(2,3)) requires extent (M)=5 cells, but L and M can both be represented by ) cells since (2,3) is a "part" of both lists. The set of parts of a list L is defined as the closure of the set {L} under the functions first and red. Many SAC-2 algorithms create overlapping list representations in a natural manner.

It is a general rule that SAC-2 algorithms do not modify their inputs. Whenever an exception is made to this rule, the exception is clearly stated in the algorithm specification. If an input to an algorithm is the location L of a list representation, this rule is intended to mean not only that the value of the input variable which conveys the location L remains unchanged but also that the cells in the representation remain unchanged. Some list processing algorithms which make exception to this rule are SFIRST, SRED, CONC, INV, LINS and LINSRT.

The external canonical form of an object is a sequence of characters (string). The external canonical form of an atom is its usual decimal representation with leading zeros and plus signs suppressed (but the external canonical form of 0 is "0"). The external canonical form of () is "()". If "ecf" denotes the external canonical form function, then ecf(comp(u,A))="("ecf(u)","a' where a=ecf(A), a' is a with its leading left parenthesis removed, and juxtaposition of strings denotes concatenation. Above we have denoted several example lists by their external canonical forms. AWRITE, LWRITE and OWRITE are algorithms which write atoms, lists and objects, respectively, in their external canonical forms. Note that no blanks occur in the external canonical form.

AREAD, LREAD and OREAD, correspondingly, read atoms, lists and objects which are input in external canonical form, and produce internal representations. However, these algorithms permit some departures from the rigid external canonical form. In atoms, plus signs and leading zeros are tolerated, but interspersed blanks, other than between a sign and a leading digit, are not. In lists, any number of blanks may occur adjacent to parentheses and commas. Note, however, that, unlike some other list processing systems, list elements must be separated by commas; blanks are not a substitute.

The SAC-2 List Processing System provides some algorithms for performing operations on sets. A set {a1,...,an} of b-integers ai is canonically represented by the list (a1,...,an) subject to the condition that a1<a2<...<an (and, when n=0, the null set is represented by the null list). In the algorithm descriptions, we refer to a set of b-integers, meaning the canonical list representation of such a set. This is a special case of a practice followed generally also in subsequent SAC-2 systems. Many types of objects (e.g., large integers, polynomials and matrices) are represented as lists, and the algorithm specifications, to avoid endless circumlocution, speak of the objects rather that the lists which represent them or, what would be still more precise, the locations of representations of the lists representing the objects. For sets of b-integers we have algorithms for the operations union, intersection and difference.

The same set-theoretic operations are provided for unordered sets. An arbitrary set, {u1,...,un}, of objects can be non-canonically represented by the list (u1,...,un) subject only to the condition that the ui be distinct (as usual, n=0 is permitted). In the algorithm descriptions, "unordered set" refers to an arbitrary set of objects with this representation.

Every main program using the SAC-2 List Processing System should begin with a call of the subroutine BEGIN1. BEGIN1 calls BEGIN0, which initializes the system global variables of the SAC-2 Basic System, and then initializes itself the system global variables belonging to the SAC-2 List Processing System. Finally, in step (3), BEGIN1 creates an available-cell list, consisting of all cells in the array SPACE. The available-cell list is a list of order one which always contains just those cells which have not been used in the representation of some other list. Each application of the algorithm COMP (which realizes the comp function) results in the removal of the first cell from the available-cell list. When the available-cell list becomes empty, COMP calls the garbage collection algorithm, GC, which creates a new available-cell list consisting of all cells which are not accessible from STACK. The location of the available-cell list is kept as the value of the system global variable AVAIL.

A main program using the List Processing System will normally conclude with a call of END1. END1 outputs a summary of all garbage collections which have occured, including the number of collections, the total number of cells reclaimed, and the total time for the collections. END1 then calls END0, which outputs the elapsed total time for the program. By setting the global variable GCM to 1, the user can also get a separate report on each garbage collection at the time it occurs.

The global variable p controls the operation of the garbage collector in a manner such that garbage collection can be kept efficient. In general, the fewer the cells reclaimed, the longer a garbage collection will take. Thus a program in which virtually all of the cells in SPACE are in active use, that is, accessible to the collector, should be avoided. Whenever the number of cells reclaimed is less than v/p, GC prints the message "TOO FEW CELLS RECLAIMED" and stops. The user can then re-run his program with a larger SPACE array (if sufficient memory is available) or with a larger value assigned to p. The distributed version of BEGIN1 sets p to 10, so that at least 20% of all cells must be reclaimed; this value of p appears to be reasonable for typical applications and environments.

As a further technique for maintaining efficient garbage collection and for minimizing the size of the SPACE array which is required, the user may set to 0 or to () any variable whose value is a list which will not be used in the subsequent computation. If a garbage collection then occurs, the cells in this list will be reclaimed (unless they also belong to an overlapping list accessible to the collector). This technique is called the maximal collection rule. Its application imposes a further burden on the programmer, so he will have to decide for himself in each case whether the extra attention is necessary or warranted by a gain in run-time efficiency.

The ALDES main programs TSTLP1 and TSTLP2 are provided as test programs for the List Processing System. Together they methodically invoke each subprogram of the system at least once (as described in the comments following each step number).

