Introduction to the SAC-2 Arithmetic System

The SAC-2 Arithmetic System depends on the SAC-2 Basic System and the SAC-2 List Processing System; all subsequent SAC-2 systems depend on the SAC-2 Arithmetic System. The SAC-2 Arithmetic System contains algorithms for operations on arbitrarily large integers and rational numbers and on "single-precision" floating-point real and complex numbers. Also there are some algorithms for interval arithmetic. The SAC-2 arithmetic capabilities will be further augmented in later versions of the system. This introduction describes the data structures and conventions which are used in the SAC-2 Arithmetic System and surveys its algorithms and capabilities.

Any main program written to use the SAC-2 Arithmetic System should have a call of the subroutine BEGIN2 as its first executable statement. BEGIN2 first calls BEGIN1 (to initialize the Basic and List Processing Systems), then initializes several system global variables and arrays belonging to the Arithmetic System. These system globals are described in the separate document "SAC-2 Global Variables" and in following parts of this Introduction. The last statement executed should normally be a call of the subroutine END1, which belongs to the list processing system.

As explained in the "Introduction to the SAC-2 List Processing System", b is a system implementation parameter which is stored (by BEGIN1) as the value of the system global variable BETA. It must be a positive integer power of 2, b = 2z, with z ³ 6. Also, one must have 3b  ² g where g is the largest positive integer such that if a is any integer with |a| <g then a is a single-precision integer for the computer on which the system is implemented. In addition to the conventions about b relating to list representation, b is the radix (or base) for the representation of arbitrarily large (indefinite-precision) integers.

If A is any positive integer then there exist unique non-negative integers a0,a1,...,an-1, with |ai| <b for 0²i²n-1 and an-1>0, such that A = S n-1 i=0 aibi. If n>1 then A is represented by the list (a0,a1,...,an-1), but if n=1 then A is represented by the atom a0=A. If A is negative then A = S n-1 i=0 aibi with ai²0 and an-1 < 0; again A is represented by (a0,a1,...,an-1) if n>1 and by a0 otherwise. 
A = 0 is represented by the atom 0. An integer a such that |a|<b is said to be a b-integer or b-digit.

The SAC-2 Arithmetic System provides arithmetic and other operations on arbitrary integers. The algorithms for the operations generally have names beginning with the letter I (for integer). Some of these algorithms may restrict one or more inputs to be b-digits. The names of these algorithms generally contain the letter D (for digit); the name of the algorithm begins with D if all inputs are so restricted.

There are two algorithms, DPROD and DQR, which should be rewritten in assembly language before extensive use is made of the system. The ALDES algorithms provided are extremely slow. Any person familiar with the assembly language of a given computer should be able to write these programs, referring to the algorithm specifications, in a few minutes.

Among the available operations on integers are the arithmetic operations of addition, subtraction, multiplication and division (quotient and remainder, quotient only, and remainder only). Also negation, sign, absolute value, maximum and minimum, and exponentiation. There is also a comparison function and Boolean odd and even functions.

There are special algorithms for multiplying or dividing by a power of 2. These algorithms exploit the assumption that b is a power of 2, and use a table of powers of 2 (the global array TABP2, initialized in BEGIN2) to achieve greater efficiency.

There are algorithms, IREAD and IWRITE, for input and output of integers in decimal notation. Externally an integer is represented by a sign followed by one or more decimal digits. It is terminated by any character other than a decimal digit following the first decimal digit; thus interspersed blanks are not permitted. It may of course, begin in one record and end in any following record. A plus sign may be omitted from input but will be omitted from output. Leading zeros are tolerated in input but are suppressed from output. Conversion between base b and decimal is achieved using an intermediate base Q. Q is the largest power of 10, 10h, which is less than b. Q and h are values of global variables, THETA  and ETA, which are computed in BEGIN2 as functions of b.

There are algorithms for computing greatest common divisors and least common multiples of integers, and for the extended Euclidean algorithm; a method similar to Lehmer's is used.

There is an algorithm, DPGEN, for generating all single-precision primes in an interval, and another, GDPGEN, which generates only the Gaussian primes.

There is an algorithm, IFACT, for the complete factorization of any integer. The method used is similar to the one proposed by Knuth in his book Seminumerical Algorithms IFACT uses a number of subalgorithms which one might also wish to use directly for various purposes.

The integer arithmetic algorithms generally use classical methods. However, there is a fast integer multiplication algorithm, IPRODK, using the Karatsuba method, for applications involving integers larger than about 200 decimal digits.

There are algorithms for generating random b-digits, random integers (with a specified maximum number of bits) and random bits. There are three system global variables, RMULT, RINC and RTERM, which are used in connection with random number generation; they are initialized in BEGIN2. If a user desires to repeat execution of a program, changing only the stream of random numbers which is used, this can be achieved by assigning an arbitrary odd positive b-digit to RTERM immediately after the call of BEGIN2.

There are some other miscellaneous non-trivial integer arithmetic algorithms which the interested  reader is invited to discover for himself by perusing the algorithm specifications.

Next, there are algorithms for modular integer arithmetic, that is, for arithmetic in Zm. For any positive integer m, Zm is the ring of integers {0,1,...,m} isomorphic to the residue class ring Z/(m) via the mapping a®a+(m). If m is a b-integer then so are the elements of Zm. Hence for reasons of efficiency there are two sets of algorithms, one for the case that the modulus m is a b-digit and one for an arbitrary modulus. The names of the algorithms in the first class generally begin with the letters MD (for modular digit) and those in the other class begin with MI (for modular integer). The first input of each such algorithm is the modulus. For example, we have c ¬ MDSUM(m,a,b) and C ¬  MISUM(M,A,B). Besides algorithms for the arihmetic operations of addition, subtraction, multiplication, division and exponentiation in Zm there are algorithms for the unique homomorphism. Hm from Z onto Zm. Especially important, there are algorithms for the Chinese remainder theorem. Also, there are algorithms for generating random elements of Zm. We denote by Z'm the ring of integers a such that -m/2<a ²m/2 which is isomorphic to Z/(m) via the mapping a ® a + (m). We do not provide arithmetic algorithms for this ring since arithmetic in Zm is somewhat simpler. However, there is an algorithm SMFMI for the natural isomorphism from Zm onto Z'm. There are, of course, no special data structures for modular integers since the elements of Zm and Z'm are just integers. For the same reason no special input/output algorithms are needed.

The rational number zero is represented by the atom zero. Thus it is indistinguishable from the integer zero. In fact, throughout SAC-2 the zero element of every ring is represented by the atom zero. For any non-zero rational number r there exist unique integers a and b such that r =a/b, b > 0 and gcd(a,b) = 1. a and b are, of course, the numerator and denominator of r. r is represented by the list (a*,b*) where a* and b* represent the integers a and b. Note that a* and, independently, b* my be either a list or an atom.

Besides algorithms for the arithmetic operations, including sign, absolute value and comparison, there are algorithms for the floor and ceiling functions of rational numbers, for converting an integer to a rational number, for reducing a pair of integers (fraction) to lowest terms and for input and output of rational numbers. The names of algorithms for rational numbers generally begin with the letters RN.

The external form of a rational number is just the numerator followed by a slash ("/") followed by the denominator. When a rational number is input there may be any number of blanks before and after the slash. Furthermore, if the denominator is 1, it may be omitted along with the slash. When a rational number is output there are no blanks surrounding the slash; whenever the denominator is 1 it is omitted along with the slash.

There is also a special algorithm, RNDWR, for writing a decimal approximation to any rational number. The user specifies the number of decimal digits following the decimal point. See the algorithm description for details.

A "single-precision floating-point real number", other than zero, is represented by a list (e,a) where e is any b-integer and a is any b-integer such that |a| ³b/2. e is the exponent and a is the (normalized) fraction. The real numbers which can be so represented are not closed under the arithmetic operations; the result obtained is an approximation. In fact, the resulting approximation is not always the best approximation (otherwise the algorithms would be considerably slower) but it is generally near the best. Exponent overflow can occur; when it does a message is  printed and the program stops. Exponent underflow is always averted by using zero as the resulting approximation. Zero, as usual, is represented by the atom zero.

A "single-precision floating-point complex number" is of the form u + vi where u snf v are single-precision floating-point real numbers. As usual, zero is represented by the atom zero. Otherwise, u +vi is represented by the list (u*,v*) where u* and v* represent u and v. The remarks above pertaining to approximation, overflow and underflow apply also to single-precision floating-point complex numbers. The names of the algorithms for operations on these numbers begin with the letters SFC. 

A single-precision floating-point interval is a closed bounded interval whose endpoints are single-precision floating-point real numbers u and v with u ² v. It is represented by the list (u*,v*) where u* and v* represent u and v. The names of algorithms for operations on single-precision floating-point intervals begin with the letters SFI. At present there is just one such algorithm; a full set will be available later.

A rational interval is a closed bounded interval whose endpoints are rational numbers a and b with a²b. It is represented by the list (a*.b*) where a* and b* represent a and b. The names of algorithms for operations on rational intervals begin with the letters RI. At present there is just one such algorithm; a full set will be available later.



