[-----------------------------------------------------------------------

    Subalgorithms fo IC

-----------------------------------------------------------------------]

[ #include tp.h ]
[ #include globs.h ]


                    CTRSET()
[Reset counters and timers. ]

(1)  [Reset all counters.] 
     STOUTL("Do you want to reset all counters [y/n]? *");
     READ; CH:=UCASE(CREAD()); if CH = 'Y' then
     { MC:=0; NC:=0; RC:=0; UC:=0; goto 3 }.
(2)  [Reset single counters.]
     STOUTL("Reset the match counter                  [y/n]? *");
     READ; CH:=UCASE(CREAD()); if CH = 'Y' then MC:=0;
     STOUTL("Reset the top set node creation counter  [y/n]? *");
     READ; CH:=UCASE(CREAD()); if CH = 'Y' then NC:=0; 
     STOUTL("Reset the reduction counter              [y/n]? *");
     READ; CH:=UCASE(CREAD()); if CH = 'Y' then RC:=0;
     STOUTL("Reset the unification counter            [y/n]? *");
     READ; CH:=UCASE(CREAD()); if CH = 'Y' then UC:=0.
(3)  [Reset all timers.] 
     STOUTL("Do you want to reset all timers [y/n]? *");
     READ; CH:=UCASE(CREAD()); if CH = 'Y' then
     { STPWT:=-CLOCK(); GTI:=0; MTI:=0; RTI:=0; UTI:=0; return }.
(4)  [Reset single timers.]
     STOUTL("Reset the stop-watch                     [y/n]? *");
     READ; CH:=UCASE(CREAD()); if CH = 'Y' then STPWT:=-CLOCK();
     STOUTL("Reset the ground reduction test time     [y/n]? *");
     READ; CH:=UCASE(CREAD()); if CH = 'Y' then GTI:=0;
     STOUTL("Reset the match time                     [y/n]? *");
     READ; CH:=UCASE(CREAD()); if CH = 'Y' then MTI:=0;
     STOUTL("Reset the reduction time                 [y/n]? *");
     READ; CH:=UCASE(CREAD()); if CH = 'Y' then RTI:=0;
     STOUTL("Reset the unification time               [y/n]? *");
     READ; CH:=UCASE(CREAD()); if CH = 'Y' then UTI:=0 ||

                    CTSHOW() 
[Show counters and timers. ]
(1)  [Show all counters.] 
     STOUTL("The number of operations performed:"); 
     STROUT("  matches:                     "); GWRITE(MC); WRITE;
     STROUT("  top set nodes created:       "); GWRITE(NC); WRITE;
     STROUT("  reductions                   "); GWRITE(RC); WRITE;
     STROUT("  unifications:                "); GWRITE(UC); WRITE.
[ (2)  [Interupt output.] STOUTL("Ready *"); READ; 
     CH:=UCASE(CREAD()); if CH = 'Y' then UC:=0.
]
(3)  [Reset all timers.] 
     BLINES(1); STROUT("Stop-watch:                    ");
     STPWT:=STPWT + CLOCK(); GWRITE(STPWT); STOUTL(" ms.");
     STPWT:=STPWT - CLOCK();
     STOUTL("The time spent during ... ");
     STROUT("  ground reduction tests:      "); 
     GWRITE(GTI); STOUTL(" ms,"); 
     STROUT("  matching:                    "); 
     GWRITE(MTI); STOUTL(" ms,");
     STROUT("  reduction:                   "); 
     GWRITE(RTI); STOUTL(" ms,"); 
     STROUT("  unification:                 "); 
     GWRITE(UTI); STOUTL(" ms,")||
     
                    GNFANA(DT,C,f,D,T,G) 
[Ground normal form analysis.
DT is a data type, C is the set of constructors of DT, f is TRUE  if
the ground normal forms of DT are freely generated by C otherwise FALSE, 
D is the set of defined operators of DT, T is a top set of DT and G is
a top set tree.]

(1)  [Constructors, defined operators, top set.]
     BLINES(1); MDTC(C,f,D,T); WRITE;
     STROUT("The size of the top set is "); 
     GWRITE(LENGTH(T)); CWRITE('.'); WRITE;
     STOUTL("Ready? *"); READ; C^:=CREAD().
(2)  [Print top set tree.] 
     STOUTL("Prefix Traversal of the top set tree: "); 
     L:=TSTTRV(G,(),0,15).
(3)  [Grammar for ground normal forms.]
     STOUTL("Ready? *"); READ; C^:=CREAD();
     TT1:=CLOCK(); G*:=TSTGRM(DT,G); TT1:=CLOCK()-TT1; GRLWRT(G*);
     STROUT("Grammar extraction time: "); GWRITE(TT1); STOUTL(" ms.") ||

                    GRTEST(DT,R,C,G)
[Ground reducibility test.
DT is a data type, R is a set of rewrite rules with regard to which
ground reducibility is tested, C is the set of constructors of DT and 
and G is the top set tree of DT.]

(1)  [Input term.]  STOUTL("Input your term, please *"); 
     T:=TEPRS(DT). 
(2)  [Compute indictively complete positions.] 
     GTI:=GTI-CLOCK(); I:=ICPR(T,R,C,G); GTI:=GTI+CLOCK();
     TDIWRT(T,(); D); STROUT(" is "); if I = () then STROUT("not"); 
     STOUTL(" ground reducible.");
     if I # () then MCICPS(T,D,I) ||

                    NORMAL(DT)
[Read term, normalize and print result.
DT is a data type. A term is read and mormalized.]
(1)  [Read term.] STOUTL("Input term:  *");
     t:=TEPRS(DT); A:=DTAX(DT).
(2)  [Normalize.] WRITE; STROUT("The normal form of "); TDIWRT(t,(); N);
     t*:=TIREDS(t,A); STROUT(" is "); TDIWRT(t*,(); N); WRITE || 

                    PROVE(DT,C*,G,T*,FREE,O*,R,A_; D*,R*,T**,G*)
[Prove a theorem.
DT is a data type, C* is the set of constructors in DT, G is the top set
tree of DT wrt the d-top set T* where d is the depth of the deepest 
subterm in T(C*,X) of a left-hand side of a rule in the TRS of DT. FREE 
TRUE if C* is a set of free constructors, otherwise FREE is FALSE.
O* is a string denoting a term ordering. R is the TRS wrt to which ground
reducibility is tested, A_ is the original (=basic) set of (completed) 
axioms.
Then a theroem may be input by the user and if it can be proved it and all
Lemmas generated during the proof may be added to the axioms in DT and R
yielding D* and R* respectivly. Also the top set T* and the top set tree
G are updated to T** and G.] 

(1)  [Initialize.]  D*:=DT; R*:=R; T**:=T*; G*:=G; 
     DTDIS(DT; N,C,V,F,A).
(2)  [Input theorem.] WRITE; STOUTL("Input a theorem [t1 == t2] *"); 
     T:=AXPRS(DT); ADIS(T; n2,m,v,n,n1).
(3)  [Normalize.] n_ := TIREDS(n,R); m_ := TIREDS(m,R); 
     if TEQU(n_,m_) then { MCGV(T,n_,N); return } 
                    else MCPIV(T,N).
(4)  [Inductive proof.] GTI:=0; D':=EKBIC(LIST1(T),DT,R,C*,G,O*). 
(5)  [Select rule set to continue.] C^:=QCC(D');
     if C^='E' then stop;
     if C^='B' then { A:=ALCOPY(A_); R*:=ALCOPY(A_) }
     else if C^='L' then A:=ALCOPY(R)
     else { DTDIS(D'; N,C,V,F,A); d:=DCSLR(A,C*);
            D:=MXDPTH(T*); RROC(A,C*; A*,l); R*:=ALCOPY(A);
            if (d >= D) then
             { CTOPS(C*,V,A*,d; T**,G*); MDTC(C*,FREE,(),T*) }
             else TSFAIL(C*)
          };
     DTAX(D*):=A ||


                    QCTOID(DT,O; O0,O*)
[Query concerning term ordering installaion of deinstallation.
O is a string denoting the selected orderings. Then O0 is a string
denoting the installed orderings and O* is a string denoting the
selected orderings. Deinstallation of orderings unselects all
orderings.]

(1)  [Are there orderings installed?] O0:=TORDGT(DT); O*:=O;
     if O0 = () then goto 5.
(2)  [Install or deinstall?] STOUTL("Do you want to");
     STOUTL("  i - install term orderings or");
     STOUTL("  d - de-install term orderings or"); 
     STOUTL("  c - cancel action         [i/d/c]? *");
     READ; c:=UCASE(CREAD()).
(3)  [Choice.] if c = 'I' then goto 5
          else if c # 'D' then return.
(4)  [Remove orderings.] O0:=TORDRM(DT); O*:=();
     STOUTL("No orderings selected!"); return.
(5)  [Install orderings.] O0:=TORDIN(DT) ||

                    b:=OSIEXT(F)
[Operator set includes external operators.
F is a set of operators. Then b is true if F includes an external
operator. In that case a message concerning the unappropiateness
of the IC programm is printed.]

(1)  [Initialize.] b:= FALSE; F':=F.
(2)  [For each f in F] while F' # () do
     { ADV(F'; f,F'); if TKIND(f) = DXT then
       { STROUT("The data type contains an external operator ");
         OPWRT(f); WRITE; 
         STOUTL("Such data types cannot be handled by the IC-program.");
         b:=TRUE; return
      } } ||

                    O*:=TERTST(O,DT)
[Select ordering and test termination.
O is a string denoting the installed orderings and DT is the data type. 
Then O* is a string denoting the selected orderings.]

(1)  [Select orderings.] O*:=TORDSE(DT,O);
     if MEMBER('S',O*) then { o:='H'; goto 3 }.
(2)  [Test termiination.] A:=DTAX(DT); o:='S';
     while A # () /\ o = 'S' do
     { ADV(A; a,A); ADIS(a;n,t1,VHS,t2,l_); CP:=CPCONS(t1,t2,0,0,());
      o:=TPPO(CP,O*); ORDWRT(t1,t2,o)
     }.
(3)  [Message.] MCTERM(o) ||

[-----------------------------------------------------------------------

   Menues and queries

-----------------------------------------------------------------------]

                    ICMENU()
[Main menue indictive completion.]
     
(1)  WRITE; STOUTL("You have following choices: "); WRITE.
(2)  STOUTL("  i - description of irreducible ground terms,");
     STOUTL("  n - normalize a term,"); 
     STOUTL("  g - check ground reducibility,");
     STOUTL("  p - prove a theorem,");
     STOUTL("  b - display the basic axioms,");
     STOUTL("  c - display the current data type,");
     STOUTL("  s - show times and counters,"); 
     STOUTL("  r - reset times and counters,");
     STOUTL("  t - set/unset trace options");
     STOUTL("  O - de/install term orderings,");
     STOUTL("  o - select a term ordering/termination test,");
     STOUTL("  h - help, print the menu"); 
     STOUTL("  q - quit."); WRITE ||

                     O := ICSMEN()
[Short main menue indictive completion.]
     safe CH,O.
(1)  STOUTL("[i/n/g/p/b/c/r/s/t/o/O/h/q] *");
     READ; c:=CREAD(); if c # 'o' then CH:=UCASE(c) else CH:=c.
(2)  if CH = 'I' then O := 1 else
     if CH = 'N' then O := 2 else
     if CH = 'G' then O := 3 else
     if CH = 'P' then O := 4 else
     if CH = 'B' then O := 5 else
     if CH = 'C' then O := 6 else
     if CH = 'S' then O := 7 else
     if CH = 'R' then O := 8 else
     if CH = 'T' then O := 9 else
     if CH = 'O' then O := 10 else
     if CH = 'o' then O := 12 else
     if CH = 'Q' then O := 0 else O := 11 ||

[-----------------------------------------------------------------------

   Messages

-----------------------------------------------------------------------]

                    MCTERM(o)
[Message concerning termination.]
(1)  STROUT("The "); if o = 'S' then STOUTL("rules are terminating.")
     else if o = 'R' then STOUTL("rules are not terminating.")
     else { STROUT("termination property of the rules cannot");
            STOUTL(" be proved. Termination is assumed!")
          } ||

                    CH:=MCCONF(C,N)
[Message concerning confluence.
C is a set of critical pairs and N is a symbol. Then CH is a character.]
(1)  [Initialize.] CH:='N'.
(2)  STROUT("The data type "); SWRT(N);
     if C # () then
      { STOUTL(" is not convergent.");
        STOUTL("The divergent critical pairs are:");
        CPLWRT(C); BLINES(1);
        STROUT("Do you want to run the Knuth-Bendix procedure");
        STOUTL(" [Y/N]? *"); READ; CH := UCASE(CREAD());
        if CH # 'Y' then
        { STROUT("The following results hold under the assumption ");
          STROUT("that the data type "); SWRT(N);
          STOUTL(" is ground confluent.");
      } }  else
      { STOUTL(" is convergent "); BLINES(1)} ||
